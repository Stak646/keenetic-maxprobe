#!/bin/sh
# keenetic-maxprobe - maximum (no-config) probe for KeeneticOS + Entware
# Version: 0.2.0

set -u

VERSION="0.2.0"
PROG="keenetic-maxprobe"

# Prefer Entware first
PATH="/opt/bin:/opt/sbin:/usr/sbin:/usr/bin:/sbin:/bin:$PATH"

# Create private artifacts by default (we chmod readable before packing)
umask 077

now_utc() { date -u '+%Y-%m-%dT%H:%M:%SZ' 2>/dev/null || date '+%Y-%m-%dT%H:%M:%SZ'; }

have() { command -v "$1" >/dev/null 2>&1; }

pick_outbase() {
  for d in /opt/var/tmp /opt/tmp /tmp; do
    if [ -d "$d" ] && [ -w "$d" ]; then
      echo "$d"; return 0
    fi
  done
  echo "/tmp"
}

HOST="$(hostname 2>/dev/null | tr -cd 'A-Za-z0-9._-' | head -c 64)"
[ -z "$HOST" ] && HOST="keenetic"
STAMP="$(now_utc | tr ':' '-' | tr -d 'Z')Z"
OUTBASE="$(pick_outbase)"
OUTDIR="$OUTBASE/${PROG}-${HOST}-${STAMP}"

mkdir -p "$OUTDIR" 2>/dev/null || true
for d in env net ndm entware hooks fs api meta analysis; do
  mkdir -p "$OUTDIR/$d" 2>/dev/null || true
done

LOG="$OUTDIR/${PROG}.log"
ERR="$OUTDIR/errors.log"

log() { printf '%s %s\n' "$(now_utc)" "$1" >> "$LOG" 2>/dev/null || true; }
err() { printf '%s %s\n' "$(now_utc)" "$1" >> "$ERR" 2>/dev/null || true; log "$1"; }

log "$PROG $VERSION starting"
log "Output: $OUTDIR"

write_meta() {
  {
    echo "program=$PROG"
    echo "version=$VERSION"
    echo "host=$HOST"
    echo "utc_start=$(now_utc)"
    echo "outdir=$OUTDIR"
    echo "path=$PATH"
  } > "$OUTDIR/meta/meta.txt" 2>/dev/null || true
}

# --- Redaction ---
redact_stream() {
  # stdin -> stdout
  # 1) redact common key=value secrets
  # 2) redact HTTP auth header tokens
  # 3) redact PEM blocks (private keys/certs)
  sed -E \
    -e 's/((pass(word)?|passwd|secret|token|api[_-]?key|psk|private[_-]?key)[[:space:]]*[:=][[:space:]]*)[^[:space:]]+/\1REDACTED/Ig' \
    -e 's/(Authorization:[[:space:]]*(Basic|Bearer)[[:space:]]+)[A-Za-z0-9+\/=._-]+/\1REDACTED/Ig' \
    -e '/-----BEGIN (RSA |EC |OPENSSH )?PRIVATE KEY-----/,/-----END (RSA |EC |OPENSSH )?PRIVATE KEY-----/c\[REDACTED_PRIVATE_KEY_BLOCK]' \
    -e '/-----BEGIN CERTIFICATE-----/,/-----END CERTIFICATE-----/c\[REDACTED_CERTIFICATE_BLOCK]' \
    2>/dev/null
}

redact_file() {
  src="$1"; dst="$2"
  [ -f "$src" ] || return 0
  if have grep && ! grep -Iq . "$src" 2>/dev/null; then
    {
      echo "[BINARY_FILE_NOT_DUMPED]"
      echo "path=$src"
    } > "$dst" 2>/dev/null || true
    return 0
  fi
  cat "$src" 2>/dev/null | redact_stream > "$dst" 2>/dev/null || cp "$src" "$dst" 2>/dev/null || true
}

# --- Command runner (always writes output, never fails the whole run) ---
run_cmd_raw() {
  # $1 outfile, $2 command string
  out="$1"; shift
  cmd="$*"
  {
    echo "# $PROG $VERSION"
    echo "# host: $HOST"
    echo "# utc: $(now_utc)"
    echo "# cmd: $cmd"
    echo
  } > "$out" 2>/dev/null || true

  sh -c "$cmd" >> "$out" 2>&1
  rc=$?
  echo >> "$out" 2>/dev/null || true
  echo "# exit_code: $rc" >> "$out" 2>/dev/null || true
  return $rc
}

run_cmd() {
  # $1 label, $2 outfile, $3... command
  label="$1"; out="$2"; shift 2
  cmd="$*"
  tmp="$OUTDIR/.tmp.$$.${label}.txt"
  mkdir -p "$(dirname "$out")" 2>/dev/null || true

  run_cmd_raw "$tmp" "$cmd"
  rc=$?
  redact_file "$tmp" "$out"
  rm -f "$tmp" 2>/dev/null || true

  if [ $rc -ne 0 ]; then
    err "FAIL [$label] exit=$rc cmd=$cmd"
  else
    log "RUN [$label] -> $out"
  fi
  return 0
}

# --- File capture ---
stat_meta() {
  src="$1"; dst="$2"
  {
    echo "# $PROG $VERSION"
    echo "# host: $HOST"
    echo "# utc: $(now_utc)"
    echo "# file: $src"
    echo
    if have stat; then
      stat "$src" 2>/dev/null || true
    else
      ls -la "$src" 2>/dev/null || true
    fi
  } > "$dst" 2>/dev/null || true
}

safe_dump_file() {
  src="$1"; rel="$2"
  meta="$OUTDIR/fs/filemeta__${rel}.txt"
  body="$OUTDIR/fs/file__${rel}.txt"
  stat_meta "$src" "$meta"

  # Only dump if size <= 512 KiB; otherwise metadata only.
  sz=0
  if have wc; then
    sz=$(wc -c < "$src" 2>/dev/null | tr -cd '0-9')
  fi
  [ -z "$sz" ] && sz=0

  if [ "$sz" -le 524288 ]; then
    redact_file "$src" "$body"
  else
    {
      echo "[SKIPPED_LARGE_FILE] size_bytes=$sz"
      echo "path=$src"
    } > "$body" 2>/dev/null || true
  fi
}

# --- Helpers ---
sanitize_rel() {
  # convert /path/to/file into safe token
  echo "$1" | sed 's#^/##' | tr '/ ' '__' | tr -cd 'A-Za-z0-9_.-'
}

# === Start ===
write_meta

# ENV
run_cmd "uname" "$OUTDIR/env/uname.txt" "uname -a"
run_cmd "os-release" "$OUTDIR/env/os_release.txt" "cat /etc/os-release 2>/dev/null || true"
run_cmd "proc-version" "$OUTDIR/env/proc_version.txt" "cat /proc/version 2>/dev/null || true"
run_cmd "cpuinfo" "$OUTDIR/env/cpuinfo.txt" "cat /proc/cpuinfo 2>/dev/null || true"
run_cmd "meminfo" "$OUTDIR/env/meminfo.txt" "cat /proc/meminfo 2>/dev/null || true"
run_cmd "uptime" "$OUTDIR/env/uptime.txt" "cat /proc/uptime 2>/dev/null || uptime 2>/dev/null || true"
run_cmd "mount" "$OUTDIR/env/mounts.txt" "mount 2>/dev/null || cat /proc/mounts 2>/dev/null || true"
run_cmd "df" "$OUTDIR/env/df.txt" "df -h 2>/dev/null || df 2>/dev/null || true"
run_cmd "df-inodes" "$OUTDIR/env/df_inodes.txt" "df -hi 2>/dev/null || true"
run_cmd "partitions" "$OUTDIR/env/partitions.txt" "cat /proc/partitions 2>/dev/null || true"
run_cmd "lsmod" "$OUTDIR/env/lsmod.txt" "lsmod 2>/dev/null || true"
run_cmd "dmesg-tail" "$OUTDIR/env/dmesg_tail.txt" "dmesg 2>/dev/null | tail -n 300 || true"
run_cmd "ps" "$OUTDIR/env/ps.txt" "ps w 2>/dev/null || ps 2>/dev/null || true"
run_cmd "top" "$OUTDIR/env/top.txt" "top -b -n 1 2>/dev/null | head -n 250 || true"

# NET
run_cmd "ip-addr" "$OUTDIR/net/ip_addr.txt" "ip addr show 2>/dev/null || true"
run_cmd "ip-link" "$OUTDIR/net/ip_link.txt" "ip link show 2>/dev/null || true"
run_cmd "ip-route" "$OUTDIR/net/ip_route.txt" "ip route show table all 2>/dev/null || ip route show 2>/dev/null || true"
run_cmd "ip-rule" "$OUTDIR/net/ip_rule.txt" "ip rule show 2>/dev/null || true"
run_cmd "ip-neigh" "$OUTDIR/net/ip_neigh.txt" "ip neigh show 2>/dev/null || true"
run_cmd "ip6-route" "$OUTDIR/net/ip6_route.txt" "ip -6 route show table all 2>/dev/null || ip -6 route show 2>/dev/null || true"
run_cmd "netstat" "$OUTDIR/net/netstat_listen.txt" "netstat -lntup 2>/dev/null || netstat -lntp 2>/dev/null || ss -lntup 2>/dev/null || true"
run_cmd "iptables-save" "$OUTDIR/net/iptables_save.txt" "iptables-save 2>/dev/null || true"
run_cmd "ip6tables-save" "$OUTDIR/net/ip6tables_save.txt" "ip6tables-save 2>/dev/null || true"
run_cmd "ipset-list" "$OUTDIR/net/ipset_list.txt" "ipset list 2>/dev/null || true"

# NDM / ndmc
if have ndmc; then
  run_cmd "ndmc-version" "$OUTDIR/ndm/ndmc_version.txt" "ndmc -h 2>&1 || true"
  run_cmd "ndm-help" "$OUTDIR/ndm/help.txt" "ndmc -c 'help' 2>&1 || true"

  # Baseline stable commands (some may not exist on all builds, we still capture errors)
  run_cmd "ndm-show-version" "$OUTDIR/ndm/show_version.txt" "ndmc -c 'show version' 2>&1 || true"
  run_cmd "ndm-show-system" "$OUTDIR/ndm/show_system.txt" "ndmc -c 'show system' 2>&1 || true"
  run_cmd "ndm-show-interface" "$OUTDIR/ndm/show_interface.txt" "ndmc -c 'show interface' 2>&1 || true"
  run_cmd "ndm-show-ip-route" "$OUTDIR/ndm/show_ip_route.txt" "ndmc -c 'show ip route' 2>&1 || true"
  run_cmd "ndm-show-ip-policy" "$OUTDIR/ndm/show_ip_policy.txt" "ndmc -c 'show ip policy' 2>&1 || true"
  run_cmd "ndm-components-list" "$OUTDIR/ndm/components_list.txt" "ndmc -c 'components list' 2>&1 || true"
  run_cmd "ndm-show-log" "$OUTDIR/ndm/show_log.txt" "ndmc -c 'show log' 2>&1 || true"

  # Config snapshots
  run_cmd "ndm-running-config" "$OUTDIR/ndm/show_running-config.txt" "ndmc -c 'show running-config' 2>&1 || true"
  run_cmd "ndm-more-system-running-config" "$OUTDIR/ndm/more_system_running-config.txt" "ndmc -c 'more system:running-config' 2>&1 || true"
  run_cmd "ndm-more-flash-startup-config" "$OUTDIR/ndm/more_flash_startup-config.txt" "ndmc -c 'more flash:startup-config' 2>&1 || true"

  # Try to fetch official diagnostics if present (safe even if missing)
  run_cmd "ndm-ci-self-test" "$OUTDIR/ndm/ci_self-test_hint.txt" "ndmc -c 'show system self-test' 2>&1 || true"
else
  err "ndmc not found; skipping KeeneticOS CLI probe"
fi

# Entware / OPKG
if have opkg; then
  run_cmd "opkg-version" "$OUTDIR/entware/opkg_version.txt" "opkg --version 2>&1 || true"
  run_cmd "opkg-list-installed" "$OUTDIR/entware/opkg_list_installed.txt" "opkg list-installed 2>/dev/null || true"
  run_cmd "opkg-status" "$OUTDIR/entware/opkg_status.txt" "opkg status 2>/dev/null || true"
  run_cmd "opkg-conf" "$OUTDIR/entware/opkg_conf_dump.txt" "cat /opt/etc/opkg.conf 2>/dev/null || true; echo; ls -la /opt/etc/opkg 2>/dev/null || true"

  # Files list for key packages (can be big but valuable)
  for pkg in opt-ndmsv2 lighttpd awg-manager nfqws2-keenetic hrneo hrweb; do
    run_cmd "opkg-info-$pkg" "$OUTDIR/entware/opkg_info_${pkg}.txt" "opkg info '$pkg' 2>/dev/null || true"
    run_cmd "opkg-files-$pkg" "$OUTDIR/entware/opkg_files_${pkg}.txt" "opkg files '$pkg' 2>/dev/null || true"
  done

  run_cmd "opt-etc-tree" "$OUTDIR/entware/opt_etc_tree.txt" "find /opt/etc -maxdepth 4 -printf '%p\t%y\t%m\t%s\t%TY-%Tm-%TdT%TH:%TM:%TS\n' 2>/dev/null || find /opt/etc -maxdepth 4 -print 2>/dev/null || true"
  run_cmd "init-d-list" "$OUTDIR/entware/init_d_list.txt" "ls -la /opt/etc/init.d 2>/dev/null || true"
  run_cmd "opt-var-log" "$OUTDIR/entware/opt_var_log_list.txt" "ls -la /opt/var/log 2>/dev/null || true"
else
  err "opkg not found; skipping Entware probe"
fi

# Hooks (both /opt and /storage variants)
for base in /opt/etc/ndm /storage/etc/ndm; do
  if [ -d "$base" ]; then
    bn="$(echo "$base" | tr '/' '_' | tr -cd 'A-Za-z0-9_')"
    run_cmd "hooks-tree-$bn" "$OUTDIR/hooks/${bn}_tree.txt" "find '$base' -maxdepth 3 -printf '%p\t%y\t%m\t%s\t%TY-%Tm-%TdT%TH:%TM:%TS\n' 2>/dev/null || find '$base' -maxdepth 3 -print 2>/dev/null || true"

    # Dump hook scripts (small files) + metadata
    find "$base" -maxdepth 3 -type f 2>/dev/null | while read -r f; do
      rel="$(sanitize_rel "$f")"
      safe_dump_file "$f" "$rel"
    done
  fi
done

# FS snapshot (lightweight)
run_cmd "fs-tree-root-maxdepth3" "$OUTDIR/fs/tree_root_maxdepth3.txt" "find / -maxdepth 3 -xdev -printf '%p\t%y\t%m\t%s\n' 2>/dev/null | head -n 200000 || true"

# Config file inventory & dumps (covers /etc, /opt/etc, /opt/var, /storage/etc)
CONF_LIST="$OUTDIR/fs/config_files_list.txt"
run_cmd "fs-config-list" "$CONF_LIST" "find /etc /opt/etc /opt/var /storage/etc 2>/dev/null \\( -path /opt/var/opkg-lists -o -path /opt/var/cache -o -path /proc -o -path /sys -o -path /dev \\) -prune -o -type f \\( -name '*.conf' -o -name '*.cfg' -o -name '*.ini' -o -name '*.json' -o -name '*.yaml' -o -name '*.yml' -o -name '*.lua' -o -name '*.sh' -o -name '*.rules' -o -name '*.list' -o -name '*.cnf' \\) -print 2>/dev/null | sort 2>/dev/null || true"

# Dump each config file (size-limited); keep runtime stable
MAX_DUMPS=2500
cnt=0
grep -E '^/' "$CONF_LIST" 2>/dev/null | while read -r f; do
  cnt=$((cnt+1))
  [ "$cnt" -gt "$MAX_DUMPS" ] && exit 0
  [ -f "$f" ] || continue
  rel="$(sanitize_rel "$f")"
  safe_dump_file "$f" "$rel"
done

# API probe: detect likely management ports (80/443 + discovered listeners)
API_OUT="$OUTDIR/api/http_probe.txt"
{
  echo "# $PROG $VERSION"
  echo "# utc: $(now_utc)"
  echo "# NOTE: No authentication is performed. Only headers are collected."
  echo
} > "$API_OUT" 2>/dev/null || true

# Candidate hosts (up to 6): localhost + first 5 IPv4 addresses
HOSTS="127.0.0.1"
if have ip; then
  IPS="$(ip -4 -o addr show 2>/dev/null | awk '{print $4}' | sed 's#/.*##' | grep -E '^[0-9.]+' | sort -u | head -n 5)"
  for h in $IPS; do HOSTS="$HOSTS $h"; done
fi

# Candidate ports: always include 80/443; plus ports where lighttpd/awg-manager/hrweb listen
PORTS="80 443 90 8088 2000 2222"
# Extract more ports from netstat output (best-effort)
if [ -f "$OUTDIR/net/netstat_listen.txt" ]; then
  EXTRA="$(grep -E 'LISTEN' "$OUTDIR/net/netstat_listen.txt" 2>/dev/null | awk '{print $4 \" \" $7}' | sed -n 's/.*:\\([0-9][0-9]*\\)[[:space:]].*\\/\\(lighttpd\\|null\\|awg-manager\\|hrweb\\).*/\\1/p' | sort -n -u | head -n 30)"
  for p in $EXTRA; do PORTS="$PORTS $p"; done
fi
PORTS="$(echo "$PORTS" | tr ' ' '\n' | grep -E '^[0-9]+$' | sort -n -u | tr '\n' ' ')"

PATHS="/ /auth /rci/ /ci/self-test.txt /ci/startup-config.txt"

for host in $HOSTS; do
  for port in $PORTS; do
    for path in $PATHS; do
      echo "## $host:$port$path (http)" >> "$API_OUT"
      # headers only
      if have curl; then
        curl -sS -D - -o /dev/null --max-time 3 "http://$host:$port$path" 2>&1 >> "$API_OUT" || true
      elif [ -x /opt/bin/curl ]; then
        /opt/bin/curl -sS -D - -o /dev/null --max-time 3 "http://$host:$port$path" 2>&1 >> "$API_OUT" || true
      fi
      echo >> "$API_OUT"

      echo "## $host:$port$path (https)" >> "$API_OUT"
      if have curl; then
        curl -k -sS -D - -o /dev/null --max-time 3 "https://$host:$port$path" 2>&1 >> "$API_OUT" || true
      elif [ -x /opt/bin/curl ]; then
        /opt/bin/curl -k -sS -D - -o /dev/null --max-time 3 "https://$host:$port$path" 2>&1 >> "$API_OUT" || true
      fi
      echo >> "$API_OUT"
    done
  done
done

# Post-analysis (creates analysis/REPORT_RU.md and analysis/REPORT_EN.md)
if have python3 && [ -x /opt/bin/keenetic-maxprobe-analyze ]; then
  run_cmd "analyze" "$OUTDIR/analysis/analyze_run.txt" "/opt/bin/keenetic-maxprobe-analyze '$OUTDIR' 2>&1 || true"
elif have python3 && [ -x "$(dirname "$0")/keenetic-maxprobe-analyze" ]; then
  run_cmd "analyze" "$OUTDIR/analysis/analyze_run.txt" "$(dirname "$0")/keenetic-maxprobe-analyze '$OUTDIR' 2>&1 || true"
fi

# Summary
{
  echo "$PROG $VERSION"
  echo "UTC start: $(grep -E '^utc_start=' "$OUTDIR/meta/meta.txt" 2>/dev/null | cut -d= -f2-)"
  echo "UTC end:   $(now_utc)"
  echo "Output dir: $OUTDIR"
  echo "Log:        $LOG"
  echo "Errors:     $ERR"
  echo
  echo "Key artifacts:"
  echo "  - NDM help:     ndm/help.txt"
  echo "  - NDM config:   ndm/show_running-config.txt (sanitized)"
  echo "  - startup-config: ndm/more_flash_startup-config.txt (sanitized)"
  echo "  - NDM log:      ndm/show_log.txt"
  echo "  - Entware pkgs: entware/opkg_list_installed.txt"
  echo "  - Hooks:        hooks/*_tree.txt"
  echo "  - API probe:    api/http_probe.txt"
  echo "  - Analysis:     analysis/REPORT_RU.md, analysis/REPORT_EN.md"
  echo
  echo "Security note: secrets (passwords/keys/tokens) are REDACTED automatically."
} > "$OUTDIR/SUMMARY.txt" 2>/dev/null || true

# Make archive readable for sharing
chmod -R a+rX "$OUTDIR" 2>/dev/null || true

ARCHIVE="$OUTDIR.tar.gz"
log "Creating archive: $ARCHIVE"
( cd "$OUTBASE" 2>/dev/null && tar -czf "$ARCHIVE" "$(basename "$OUTDIR")" 2>/dev/null ) || true
if have sha256sum; then
  ( cd "$OUTBASE" 2>/dev/null && sha256sum "$(basename "$ARCHIVE")" > "$ARCHIVE.sha256" 2>/dev/null ) || true
fi

log "$PROG finished"

echo "$ARCHIVE"
