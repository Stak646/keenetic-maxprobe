#!/bin/sh
# keenetic-maxprobe — maximal KeeneticOS + Entware probe
# Version: 0.6.2
#
# Default mode: FULL (may include sensitive data).
# Safe mode: --mode safe (keeps copies redacted + produces redaction guides).
# Extreme mode: --mode extream (deepest, can install runtimes, no safety limits).
#
# Designed for Keenetic routers with Entware (OPKG). Best-effort, POSIX sh.

set -u

VERSION="0.6.2"
PROG="keenetic-maxprobe"

# Prefer Entware first
PATH="/opt/bin:/opt/sbin:/usr/sbin:/usr/bin:/sbin:/bin:$PATH"
umask 077

# ---------------- defaults (config/CLI can override) ----------------
LANG_UI="ru"         # ru|en (UI prompts)
PROFILE="auto"       # auto|forensic|diagnostic|lite
MODE="full"          # full|safe|extream
COLLECTORS="all"     # all|shonly|shpy|custom
CUSTOM_COLLECTORS="" # comma list for custom: py,go,lua,node,perl,ruby
OUTDIR=""            # empty=auto

CLEAN_OLD=0
CLEAN_TMP=0
DEBUG=1
SPINNER=1
YES=0

# Dependency handling
NO_INSTALL=0          # if 1: do not install via opkg
DEPS_MODE="cleanup"   # cleanup|keep
DEPS_LEVEL="core"     # core|collectors (collectors installs language runtimes if missing)

# Resource limits (best-effort)
MAX_CPU=85            # percent 0..100
MAX_MEM=95            # percent 0..100

# Parallelism for independent collectors (best-effort)
JOBS="auto"           # auto|N

# Init wizard
INIT=0
CONFIG_PATH="/opt/etc/keenetic-maxprobe.conf"

SHARE_DIR="/opt/share/keenetic-maxprobe"
COLLECTORS_DIR="$SHARE_DIR/collectors"

# allow running from repo checkout
if [ ! -d "$COLLECTORS_DIR" ]; then
  _sd="$(CDPATH= cd -- "$(dirname -- "$0")" 2>/dev/null && pwd 2>/dev/null || echo "")"
  if [ -n "$_sd" ] && [ -d "$_sd/../collectors" ]; then
    COLLECTORS_DIR="$_sd/../collectors"
  fi
fi

# ---------------- runtime globals ----------------
OUTBASE=""
BASE=""
WORK=""
ARCHIVE=""
RUNLOG=""
ERRLOG=""
PHASE_FILE=""
PROGRESS_FILE=""
SPINNER_PID=""
METRICS_PID=""
START_EPOCH="0"
TOTAL_STEPS=0
STEP_NO=0
JOBS_N=1

# deps tracking (only what we install explicitly)
INSTALLED_TOP_PKGS=""

# ---------------- tiny i18n (DO NOT SHADOW coreutils like `tr`) ----------------
T() {
  key="$1"
  case "${LANG_UI:-ru}" in
    en)
      case "$key" in
        WIZ_TITLE) echo "== keenetic-maxprobe init wizard ==" ;;
        WIZ_LANG) echo "UI language: ru/en" ;;
        WIZ_PROFILE) echo "Profile: auto/forensic/diagnostic/lite" ;;
        WIZ_PROFILE_HELP) echo "auto=smart; forensic=max; diagnostic=balanced; lite=min" ;;
        WIZ_MODE) echo "Mode: full/safe/extream" ;;
        WIZ_MODE_HELP) echo "full=max data; safe=redact some; extream=deepest, no safety limits" ;;
        WIZ_COLLECTORS) echo "Collectors: all/shonly/shpy/custom" ;;
        WIZ_COLLECTORS_HELP) echo "all=all available; shonly=shell only; shpy=shell+python; custom=list" ;;
        WIZ_CUSTOM) echo "Custom collectors (comma list: py,go,lua,node,perl,ruby)" ;;
        WIZ_OUTDIR) echo "Output directory for final archive (empty=auto)" ;;
        WIZ_CLEAN_OLD) echo "Clean old keenetic-maxprobe-* archives in output directory?" ;;
        WIZ_CLEAN_TMP) echo "Clean /tmp before run? (may help if low space)" ;;
        WIZ_DEBUG) echo "Enable debug? (more logs, longer run)" ;;
        WIZ_DEPS_CLEANUP) echo "Cleanup temporarily installed packages after run?" ;;
        WIZ_DEPS_LEVEL) echo "Install missing collector runtimes (python/node/...) in extream mode?" ;;
        WIZ_SPINNER) echo "Show spinner/progress animation?" ;;
        WIZ_JOBS) echo "Parallel collectors jobs (auto/1/2/..)" ;;
        WIZ_LIMITS) echo "Resource limits: max CPU % and max RAM %" ;;
        SAVED) echo "[+] Saved:" ;;
        STARTING) echo "[+] Starting probe" ;;
        DONE) echo "[+] Done. Archive:" ;;
        WARN_SPACE) echo "[!] Low free space in output dir; consider --outdir or --clean-tmp" ;;
        *) echo "$key" ;;
      esac
      ;;
    *)
      case "$key" in
        WIZ_TITLE) echo "== мастер настройки keenetic-maxprobe ==" ;;
        WIZ_LANG) echo "Язык интерфейса: ru/en" ;;
        WIZ_PROFILE) echo "Профиль: auto/forensic/diagnostic/lite" ;;
        WIZ_PROFILE_HELP) echo "auto=умно; forensic=максимум; diagnostic=баланс; lite=минимум" ;;
        WIZ_MODE) echo "Режим: full/safe/extream" ;;
        WIZ_MODE_HELP) echo "full=максимум; safe=частичная защита; extream=максимум без ограничений" ;;
        WIZ_COLLECTORS) echo "Collectors: all/shonly/shpy/custom" ;;
        WIZ_COLLECTORS_HELP) echo "all=все доступные; shonly=только shell; shpy=shell+python; custom=список" ;;
        WIZ_CUSTOM) echo "Список collectors (через запятую: py,go,lua,node,perl,ruby)" ;;
        WIZ_OUTDIR) echo "Папка для финального архива (пусто=авто)" ;;
        WIZ_CLEAN_OLD) echo "Удалить старые keenetic-maxprobe-* архивы в папке вывода?" ;;
        WIZ_CLEAN_TMP) echo "Очистить /tmp перед запуском? (помогает при нехватке места)" ;;
        WIZ_DEBUG) echo "Включить debug? (больше логов, дольше)" ;;
        WIZ_DEPS_CLEANUP) echo "Удалять временно установленные пакеты после запуска?" ;;
        WIZ_DEPS_LEVEL) echo "Ставить отсутствующие runtimes collectors (python/node/...) в extream?" ;;
        WIZ_SPINNER) echo "Показывать анимацию прогресса?" ;;
        WIZ_JOBS) echo "Параллельность collectors (auto/1/2/..)" ;;
        WIZ_LIMITS) echo "Лимиты ресурсов: CPU% и RAM%" ;;
        SAVED) echo "[+] Сохранено:" ;;
        STARTING) echo "[+] Старт диагностики" ;;
        DONE) echo "[+] Готово. Архив:" ;;
        WARN_SPACE) echo "[!] Мало свободного места в папке вывода; используйте --outdir или --clean-tmp" ;;
        *) echo "$key" ;;
      esac
      ;;
  esac
}

# ---------------- basic helpers ----------------
now_utc() { date -u '+%Y-%m-%dT%H:%M:%SZ' 2>/dev/null || date '+%Y-%m-%dT%H:%M:%SZ' 2>/dev/null || date '+%s' 2>/dev/null || echo "0"; }
have() { command -v "$1" >/dev/null 2>&1; }

ensure_dir() {
  d="$1"
  [ -n "$d" ] || return 1
  [ -d "$d" ] && return 0
  mkdir -p "$d" 2>/dev/null || return 1
  return 0
}

say() {
  msg="$*"
  ts="$(now_utc)"
  printf '%s %s\n' "$ts" "$msg" >&2
  if [ -n "${RUNLOG:-}" ]; then
    printf '%s %s\n' "$ts" "$msg" >>"$RUNLOG" 2>/dev/null || true
  fi
}

warn() {
  msg="$*"
  ts="$(now_utc)"
  printf '%s [!] %s\n' "$ts" "$msg" >&2
  if [ -n "${ERRLOG:-}" ]; then
    printf '%s [!] %s\n' "$ts" "$msg" >>"$ERRLOG" 2>/dev/null || true
  fi
}

die() { warn "$*"; exit 1; }

json_escape() {
  # escape for JSON string value, remove NUL and other control chars
  # keep UTF-8 best-effort
  printf '%s' "$1" | tr -d '\000' 2>/dev/null | sed 's/\\/\\\\/g; s/"/\\"/g; s/\r/\\r/g; s/\t/\\t/g; s/\n/\\n/g'
}

# phase/progress are best-effort; DO NOT write to /meta if WORK is empty
set_phase() {
  ph="$*"
  if [ -n "${PHASE_FILE:-}" ] && [ -n "${WORK:-}" ] && [ -d "$WORK/meta" ]; then
    printf '%s\n' "$ph" >"$PHASE_FILE" 2>/dev/null || true
  fi
}

set_progress() {
  if [ -n "${PROGRESS_FILE:-}" ] && [ -n "${WORK:-}" ] && [ -d "$WORK/meta" ]; then
    printf '%s/%s\n' "$STEP_NO" "$TOTAL_STEPS" >"$PROGRESS_FILE" 2>/dev/null || true
  fi
}

# ---------------- config ----------------
load_config() {
  [ -f "$CONFIG_PATH" ] || return 0
  # shellcheck disable=SC1090
  . "$CONFIG_PATH" 2>/dev/null || true
  LANG_UI="${LANG_UI:-ru}"
  PROFILE="${PROFILE:-auto}"
  MODE="${MODE:-full}"
  COLLECTORS="${COLLECTORS:-all}"
  CUSTOM_COLLECTORS="${CUSTOM_COLLECTORS:-}"
  OUTDIR="${OUTDIR:-}"
  CLEAN_OLD="${CLEAN_OLD:-0}"
  CLEAN_TMP="${CLEAN_TMP:-0}"
  DEBUG="${DEBUG:-1}"
  SPINNER="${SPINNER:-1}"
  NO_INSTALL="${NO_INSTALL:-0}"
  DEPS_MODE="${DEPS_MODE:-cleanup}"
  DEPS_LEVEL="${DEPS_LEVEL:-core}"
  MAX_CPU="${MAX_CPU:-85}"
  MAX_MEM="${MAX_MEM:-95}"
  JOBS="${JOBS:-auto}"
}

save_config() {
  ensure_dir "$(dirname "$CONFIG_PATH")" || true
  cat >"$CONFIG_PATH" <<EOF
# keenetic-maxprobe config (generated by --init)
LANG_UI="${LANG_UI}"
PROFILE="${PROFILE}"
MODE="${MODE}"
COLLECTORS="${COLLECTORS}"
CUSTOM_COLLECTORS="${CUSTOM_COLLECTORS}"
OUTDIR="${OUTDIR}"
CLEAN_OLD="${CLEAN_OLD}"
CLEAN_TMP="${CLEAN_TMP}"
DEBUG="${DEBUG}"
SPINNER="${SPINNER}"
NO_INSTALL="${NO_INSTALL}"
DEPS_MODE="${DEPS_MODE}"
DEPS_LEVEL="${DEPS_LEVEL}"
MAX_CPU="${MAX_CPU}"
MAX_MEM="${MAX_MEM}"
JOBS="${JOBS}"
EOF
}

ask() {
  prompt="$1"; def="$2"
  if [ "$YES" -eq 1 ]; then
    printf '%s' "$def"
    return 0
  fi
  printf '%s [%s]: ' "$prompt" "$def" >&2
  IFS= read -r ans || ans=""
  [ -n "$ans" ] || ans="$def"
  printf '%s' "$ans"
}

ask_yn() {
  prompt="$1"; def="$2"
  if [ "$YES" -eq 1 ]; then
    [ "$def" = "y" ] && return 0 || return 1
  fi
  while :; do
    ans="$(ask "$prompt (y/n)" "$def")"
    case "$ans" in y|Y|yes) return 0 ;; n|N|no) return 1 ;; esac
  done
}

init_wizard() {
  echo >&2
  echo "$(T WIZ_TITLE)" >&2
  echo >&2

  lang="$(ask "$(T WIZ_LANG)" "$LANG_UI")"
  case "$lang" in ru|en) LANG_UI="$lang" ;; esac

  echo >&2; echo "$(T WIZ_PROFILE_HELP)" >&2
  p="$(ask "$(T WIZ_PROFILE)" "$PROFILE")"
  case "$p" in auto|forensic|diagnostic|lite) PROFILE="$p" ;; esac

  echo >&2; echo "$(T WIZ_MODE_HELP)" >&2
  m="$(ask "$(T WIZ_MODE)" "$MODE")"
  case "$m" in full|safe|extream) MODE="$m" ;; esac

  echo >&2; echo "$(T WIZ_COLLECTORS_HELP)" >&2
  c="$(ask "$(T WIZ_COLLECTORS)" "$COLLECTORS")"
  case "$c" in all|shonly|shpy|custom) COLLECTORS="$c" ;; esac
  if [ "$COLLECTORS" = "custom" ]; then
    CUSTOM_COLLECTORS="$(ask "$(T WIZ_CUSTOM)" "$CUSTOM_COLLECTORS")"
  fi

  OUTDIR="$(ask "$(T WIZ_OUTDIR)" "$OUTDIR")"

  if ask_yn "$(T WIZ_CLEAN_OLD)" "n"; then CLEAN_OLD=1; else CLEAN_OLD=0; fi
  if ask_yn "$(T WIZ_CLEAN_TMP)" "n"; then CLEAN_TMP=1; else CLEAN_TMP=0; fi
  if ask_yn "$(T WIZ_DEBUG)" "y"; then DEBUG=1; else DEBUG=0; fi
  if ask_yn "$(T WIZ_DEPS_CLEANUP)" "y"; then DEPS_MODE="cleanup"; else DEPS_MODE="keep"; fi
  if ask_yn "$(T WIZ_SPINNER)" "y"; then SPINNER=1; else SPINNER=0; fi

  JOBS="$(ask "$(T WIZ_JOBS)" "$JOBS")"
  MAX_CPU="$(ask "$(T WIZ_LIMITS) (CPU)" "$MAX_CPU")"
  MAX_MEM="$(ask "$(T WIZ_LIMITS) (RAM)" "$MAX_MEM")"

  if [ "$MODE" = "extream" ]; then
    if ask_yn "$(T WIZ_DEPS_LEVEL)" "n"; then DEPS_LEVEL="collectors"; else DEPS_LEVEL="core"; fi
  fi

  save_config
  echo >&2
  echo "$(T SAVED) $CONFIG_PATH" >&2
}

usage() {
  cat >&2 <<'USAGE'
keenetic-maxprobe [options]

Core:
  --init                    interactive wizard (saves /opt/etc/keenetic-maxprobe.conf)
  --lang {ru|en}            UI language for prompts (default: ru)
  --mode {full|safe|extream}
  --profile {auto|forensic|diagnostic|lite}
  --collectors {all|shonly|shpy|custom}
  --custom-collectors LIST  comma list: py,go,lua,node,perl,ruby
  --outdir DIR              where to store the final archive (empty=auto)
  --clean-old               remove old keenetic-maxprobe-*.tar.gz in output dir
  --clean-tmp               remove /tmp/keenetic-maxprobe-* before run

Debug / UX:
  --debug | --no-debug
  --spinner | --no-spinner
  -y, --yes                 non-interactive (defaults)

Dependencies:
  --no-install              do not install anything via opkg
  --deps-mode {cleanup|keep}
  --deps-level {core|collectors}

Performance (best-effort):
  --max-cpu N               default 85
  --max-mem N               default 95
  --jobs N|auto             parallel jobs for independent collectors

Examples:
  keenetic-maxprobe
  keenetic-maxprobe --mode safe
  keenetic-maxprobe --mode extream --deps-level collectors
USAGE
}

parse_args() {
  while [ $# -gt 0 ]; do
    case "$1" in
      --init) INIT=1 ;;
      --lang) LANG_UI="${2:-ru}"; shift ;;
      --mode) MODE="${2:-full}"; shift ;;
      --extream|--extreme) MODE="extream" ;;
      --profile) PROFILE="${2:-auto}"; shift ;;
      --collectors) COLLECTORS="${2:-all}"; shift ;;
      --custom-collectors) CUSTOM_COLLECTORS="${2:-}"; COLLECTORS="custom"; shift ;;
      --outdir) OUTDIR="${2:-}"; shift ;;
      --clean-old) CLEAN_OLD=1 ;;
      --clean-tmp) CLEAN_TMP=1 ;;
      --debug) DEBUG=1 ;;
      --no-debug) DEBUG=0 ;;
      --spinner) SPINNER=1 ;;
      --no-spinner) SPINNER=0 ;;
      -y|--yes) YES=1 ;;
      --no-install) NO_INSTALL=1 ;;
      --deps-mode) DEPS_MODE="${2:-cleanup}"; shift ;;
      --deps-level) DEPS_LEVEL="${2:-core}"; shift ;;
      --max-cpu) MAX_CPU="${2:-85}"; shift ;;
      --max-mem) MAX_MEM="${2:-95}"; shift ;;
      --jobs) JOBS="${2:-auto}"; shift ;;
      -h|--help) usage; exit 0 ;;
      *) warn "Unknown arg: $1"; usage; exit 2 ;;
    esac
    shift
  done
}

# ---------------- metrics (best-effort) ----------------
get_cores() {
  c="$(grep -c '^processor' /proc/cpuinfo 2>/dev/null || echo 1)"
  [ "$c" -gt 0 ] 2>/dev/null || c=1
  echo "$c"
}

mem_used_pct_now() {
  mt="$(awk '/MemTotal:/ {print $2}' /proc/meminfo 2>/dev/null || echo 0)"
  ma="$(awk '/MemAvailable:/ {print $2}' /proc/meminfo 2>/dev/null || echo 0)"
  if [ "${ma:-0}" -eq 0 ] 2>/dev/null; then
    mf="$(awk '/MemFree:/ {print $2}' /proc/meminfo 2>/dev/null || echo 0)"
    b="$(awk '/Buffers:/ {print $2}' /proc/meminfo 2>/dev/null || echo 0)"
    c="$(awk '/^Cached:/ {print $2}' /proc/meminfo 2>/dev/null || echo 0)"
    ma=$((mf + b + c))
  fi
  if [ "${mt:-0}" -gt 0 ] 2>/dev/null; then
    used=$((mt - ma))
    pct=$(( (100 * used) / mt ))
    [ "$pct" -lt 0 ] && pct=0
    [ "$pct" -gt 100 ] && pct=100
    echo "$pct"
  else
    echo "0"
  fi
}

cpu_used_pct_delta() {
  # returns integer 0..100 between two reads
  # read /proc/stat aggregated cpu line
  line="$(head -n 1 /proc/stat 2>/dev/null || echo "")"
  set -- $line
  # cpu user nice system idle iowait irq softirq steal guest guest_nice
  idle=$5
  iowait=${6:-0}
  total=0
  # sum numeric fields from $2 onwards
  for v in $2 $3 $4 $5 $6 $7 $8 $9; do total=$((total + v)); done
  idle_all=$((idle + iowait))
  echo "$total $idle_all"
}

start_metrics() {
  [ -n "$WORK" ] || return 0
  ensure_dir "$WORK/meta" || return 0
  METRICS_TSV="$WORK/meta/metrics.tsv"
  : >"$METRICS_TSV" 2>/dev/null || true
  (
    prev="$(cpu_used_pct_delta)"; prev_total="${prev%% *}"; prev_idle="${prev##* }"
    while :; do
      sleep 1
      cur="$(cpu_used_pct_delta)"; total="${cur%% *}"; idle="${cur##* }"
      dt=$((total - prev_total)); di=$((idle - prev_idle))
      if [ "$dt" -gt 0 ] 2>/dev/null; then
        cpu=$(( (100 * (dt - di)) / dt ))
      else
        cpu=0
      fi
      [ "$cpu" -lt 0 ] && cpu=0
      [ "$cpu" -gt 100 ] && cpu=100
      mem="$(mem_used_pct_now)"
      printf '%s\tcpu=%s\tmem=%s\n' "$(now_utc)" "$cpu" "$mem" >>"$METRICS_TSV" 2>/dev/null || true
      prev_total="$total"; prev_idle="$idle"
    done
  ) &
  METRICS_PID="$!"
}

stop_metrics() {
  if [ -n "${METRICS_PID:-}" ]; then
    kill "$METRICS_PID" 2>/dev/null || true
    METRICS_PID=""
  fi
}

# ---------------- spinner (tty only) ----------------
start_spinner() {
  [ "$SPINNER" -eq 1 ] || return 0
  [ -t 2 ] || return 0
  (
    chars='-\|/'
    i=0
    while :; do
      i=$(( (i + 1) % 4 ))
      ch="$(printf '%s' "$chars" | cut -c $((i+1)))"
      ph="..."
      if [ -n "${PHASE_FILE:-}" ] && [ -f "$PHASE_FILE" ]; then
        ph="$(head -n 1 "$PHASE_FILE" 2>/dev/null || echo "...")"
      fi
      # best-effort last metric
      cpu=""; mem=""
      if [ -n "${METRICS_TSV:-}" ] && [ -f "$METRICS_TSV" ]; then
        last="$(tail -n 1 "$METRICS_TSV" 2>/dev/null || true)"
        cpu="$(printf '%s' "$last" | sed -n 's/.*cpu=\([0-9][0-9]*\).*/\1/p')"
        mem="$(printf '%s' "$last" | sed -n 's/.*mem=\([0-9][0-9]*\).*/\1/p')"
      fi
      if [ -n "$cpu" ] && [ -n "$mem" ]; then
        printf '\r[%s] %s | CPU~%s%% MEM~%s%% ' "$ch" "$ph" "$cpu" "$mem" >&2
      else
        printf '\r[%s] %s ' "$ch" "$ph" >&2
      fi
      sleep 1
    done
  ) &
  SPINNER_PID="$!"
}

stop_spinner() {
  if [ -n "${SPINNER_PID:-}" ]; then
    kill "$SPINNER_PID" 2>/dev/null || true
    SPINNER_PID=""
    [ -t 2 ] && printf '\r%*s\r' 120 '' >&2 || true
  fi
}

# ---------------- resource throttle (best-effort) ----------------
throttle_if_needed() {
  # Avoid heavy steps when system is already overloaded (best-effort)
  max_cpu="${MAX_CPU:-85}"
  max_mem="${MAX_MEM:-95}"
  # Use last metrics if present, else compute mem only
  cpu=0
  if [ -n "${METRICS_TSV:-}" ] && [ -f "$METRICS_TSV" ]; then
    last="$(tail -n 1 "$METRICS_TSV" 2>/dev/null || true)"
    cpu="$(printf '%s' "$last" | sed -n 's/.*cpu=\([0-9][0-9]*\).*/\1/p')"
    [ -n "$cpu" ] || cpu=0
  fi
  mem="$(mem_used_pct_now)"
  # sleep in small increments
  tries=0
  while [ "$tries" -lt 30 ]; do
    if [ "$cpu" -ge "$max_cpu" ] 2>/dev/null || [ "$mem" -ge "$max_mem" ] 2>/dev/null; then
      sleep 2
      tries=$((tries + 1))
      mem="$(mem_used_pct_now)"
      if [ -n "${METRICS_TSV:-}" ] && [ -f "$METRICS_TSV" ]; then
        last="$(tail -n 1 "$METRICS_TSV" 2>/dev/null || true)"
        cpu="$(printf '%s' "$last" | sed -n 's/.*cpu=\([0-9][0-9]*\).*/\1/p')"
        [ -n "$cpu" ] || cpu=0
      fi
    else
      break
    fi
  done
}

# ---------------- output selection & cleanup ----------------
pick_outdir() {
  if [ -n "$OUTDIR" ]; then
    ensure_dir "$OUTDIR" && echo "$OUTDIR" && return 0
  fi
  for d in /opt/var/tmp /opt/tmp /tmp /var/tmp; do
    if ensure_dir "$d" 2>/dev/null; then echo "$d"; return 0; fi
  done
  echo "/tmp"
}

check_free_space_warn() {
  [ -n "$OUTBASE" ] || return 0
  if have df; then
    avail="$(df -k "$OUTBASE" 2>/dev/null | awk 'NR==2 {print $4}' 2>/dev/null || echo 0)"
    # warn if < 64MB
    if [ "${avail:-0}" -gt 0 ] 2>/dev/null && [ "$avail" -lt 65536 ] 2>/dev/null; then
      warn "$(T WARN_SPACE)"
    fi
  fi
}

clean_tmp_dir() {
  [ "$CLEAN_TMP" -eq 1 ] || return 0
  # do NOT call set_phase here (WORK may be empty on early run)
  rm -rf /tmp/keenetic-maxprobe-* 2>/dev/null || true
}

clean_old_outputs() {
  [ "$CLEAN_OLD" -eq 1 ] || return 0
  [ -n "$OUTBASE" ] || return 0
  # only delete finished archives, never .work
  find "$OUTBASE" -maxdepth 1 -type f -name 'keenetic-maxprobe-*.tar.gz' -delete 2>/dev/null || true
  find "$OUTBASE" -maxdepth 1 -type f -name 'keenetic-maxprobe-*.tar.gz.sha256' -delete 2>/dev/null || true
}

# ---------------- deps (best-effort) ----------------
opkg_installed() { have opkg && opkg status "$1" >/dev/null 2>&1; }

install_pkg() {
  pkg="$1"
  [ "$NO_INSTALL" -eq 1 ] && return 0
  have opkg || return 0
  if opkg_installed "$pkg"; then return 0; fi
  say "[+] opkg install $pkg (best-effort)"
  opkg update >/dev/null 2>&1 || true
  if opkg install "$pkg" >/dev/null 2>&1; then
    INSTALLED_TOP_PKGS="${INSTALLED_TOP_PKGS} $pkg"
    return 0
  fi
  warn "opkg: cannot install $pkg (skipping)"
  return 0
}

maybe_install_collectors_runtimes() {
  [ "$MODE" = "extream" ] || return 0
  [ "$DEPS_LEVEL" = "collectors" ] || return 0
  # Only install runtimes needed for collectors that are enabled
  want_py=0; want_node=0; want_lua=0; want_perl=0; want_ruby=0
  case "$COLLECTORS" in
    all) want_py=1; want_node=1; want_lua=1; want_perl=1; want_ruby=1 ;;
    shpy) want_py=1 ;;
    custom)
      echo "$CUSTOM_COLLECTORS" | grep -q 'py' && want_py=1 || true
      echo "$CUSTOM_COLLECTORS" | grep -q 'node' && want_node=1 || true
      echo "$CUSTOM_COLLECTORS" | grep -q 'lua' && want_lua=1 || true
      echo "$CUSTOM_COLLECTORS" | grep -q 'perl' && want_perl=1 || true
      echo "$CUSTOM_COLLECTORS" | grep -q 'ruby' && want_ruby=1 || true
      ;;
  esac

  if [ "$want_py" -eq 1 ] && ! have python3; then install_pkg python3 || install_pkg python3-light || true; fi
  if [ "$want_node" -eq 1 ] && ! have node; then install_pkg node || true; fi
  if [ "$want_lua" -eq 1 ] && ! have lua; then install_pkg lua || true; fi
  if [ "$want_perl" -eq 1 ] && ! have perl; then install_pkg perl || true; fi
  if [ "$want_ruby" -eq 1 ] && ! have ruby; then install_pkg ruby || true; fi
}

cleanup_temp_packages() {
  [ "$DEPS_MODE" = "cleanup" ] || return 0
  have opkg || return 0
  # Only remove top-level pkgs we explicitly installed.
  for pkg in $INSTALLED_TOP_PKGS; do
    say "[+] opkg remove $pkg (best-effort)"
    opkg remove "$pkg" >/dev/null 2>&1 || warn "opkg remove failed: $pkg"
  done
}

# ---------------- steps orchestration ----------------
step() {
  STEP_NO=$((STEP_NO + 1))
  set_progress
  set_phase "$*"
  say "[*] $STEP_NO/$TOTAL_STEPS | $*"
  throttle_if_needed || true
}

# ---------------- collectors & collection ----------------
read_device_model() {
  # best-effort: strip NUL terminators from device-tree strings
  if [ -r /proc/device-tree/model ]; then
    (cat /proc/device-tree/model 2>/dev/null || true) | tr -d '\000' 2>/dev/null | sed 's/[[:space:]]\+$//' || true
    return 0
  fi
  echo ""
}

detect_arch() {
  if have opkg; then
    opkg print-architecture 2>/dev/null | head -n 1 | awk '{print $2}' 2>/dev/null && return 0
  fi
  uname -m 2>/dev/null || echo "unknown"
}

collect_meta() {
  ensure_dir "$WORK/meta" || true
  dev="$(read_device_model)"
  arch="$(detect_arch)"
  cores="$(get_cores)"
  mem_kb="$(awk '/MemTotal:/ {print $2}' /proc/meminfo 2>/dev/null || echo 0)"
  jobs="${JOBS_N}"
  ts="$(now_utc)"

  # write minimal platform text
  {
    echo "tool=$PROG"
    echo "version=$VERSION"
    echo "ts_utc=$ts"
    echo "device_model=$dev"
    echo "arch=$arch"
    echo "cores=$cores"
    echo "mem_total_kb=$mem_kb"
  } >"$WORK/meta/platform.txt" 2>/dev/null || true

  # valid JSON (avoid invalid escapes like \000)
  dev_js="$(json_escape "$dev")"
  {
    printf '{\n'
    printf '  "tool": "%s",\n' "$(json_escape "$PROG")"
    printf '  "version": "%s",\n' "$(json_escape "$VERSION")"
    printf '  "ts_utc": "%s",\n' "$(json_escape "$ts")"
    printf '  "lang_ui": "%s",\n' "$(json_escape "$LANG_UI")"
    printf '  "profile": "%s",\n' "$(json_escape "$PROFILE")"
    printf '  "mode": "%s",\n' "$(json_escape "$MODE")"
    printf '  "collectors": "%s",\n' "$(json_escape "$COLLECTORS")"
    printf '  "jobs": "%s",\n' "$(json_escape "$jobs")"
    printf '  "limits": { "max_cpu_pct": %s, "max_mem_pct": %s },\n' "${MAX_CPU:-85}" "${MAX_MEM:-95}"
    printf '  "device_model": "%s",\n' "$dev_js"
    printf '  "arch": "%s",\n' "$(json_escape "$arch")"
    printf '  "cores": "%s",\n' "$(json_escape "$cores")"
    printf '  "mem_total_kb": "%s"\n' "$(json_escape "$mem_kb")"
    printf '}\n'
  } >"$WORK/meta/profile_selected.json" 2>/dev/null || true
}

collect_proc() {
  ensure_dir "$WORK/sys" || true
  # bounded proc snapshot (skip huge /proc entries)
  if have tar; then
    (cd /proc 2>/dev/null && tar -cf - \
      cpuinfo meminfo uptime loadavg version cmdline mounts \
      net/* 2>/dev/null) | tar -xf - -C "$WORK/sys" 2>/dev/null || true
  fi
}

collect_sys_commands() {
  ensure_dir "$WORK/sys" || true
  (uname -a 2>/dev/null || true) >"$WORK/sys/uname.txt" 2>/dev/null || true
  (dmesg 2>/dev/null | tail -n 500 || true) >"$WORK/sys/dmesg_tail.txt" 2>/dev/null || true
  (ps w 2>/dev/null || ps 2>/dev/null || true) >"$WORK/sys/ps.txt" 2>/dev/null || true
}

# --- filesystem mirror helpers ---
rsync_available() { have rsync; }

mirror_with_rsync() {
  src="$1"; dst="$2"
  ensure_dir "$dst" || return 0
  rsync -a --delete \
    --exclude='keenetic-maxprobe-*' \
    --exclude='*.tar.gz' \
    --exclude='*.tar.gz.sha256' \
    --exclude='.work' \
    --exclude='.work/**' \
    --exclude='var/tmp/**' \
    --exclude='tmp/**' \
    --exclude='opt/var/tmp/**' \
    --exclude='opt/tmp/**' \
    --exclude='var/log/**' \
    --exclude='opt/var/log/**' \
    "$src"/ "$dst"/ >/dev/null 2>&1 || true
}

mirror_manifest_only() {
  # produce manifest of files (path,size,mtime,mode) without copying full data
  src="$1"; out="$2"
  ensure_dir "$(dirname "$out")" || true
  if have find && have stat; then
    (cd "$src" 2>/dev/null && find . -xdev -type f 2>/dev/null | head -n 50000 | while IFS= read -r p; do
      st="$(stat -c '%s\t%Y\t%a' "$p" 2>/dev/null || echo '?\t?\t?')"
      printf '%s\t%s\n' "$p" "$st"
    done) >"$out" 2>/dev/null || true
  else
    (cd "$src" 2>/dev/null && find . -xdev 2>/dev/null | head -n 50000) >"$out" 2>/dev/null || true
  fi
}

mirror_configs() {
  ensure_dir "$WORK/fs" || true
  # Always mirror config roots (bounded & important)
  for src in /etc /opt/etc /storage/etc /opt/var/log /opt/var/run; do
    [ -d "$src" ] || continue
    dst="$WORK/fs$(printf '%s' "$src")"
    ensure_dir "$dst" || true
    if rsync_available; then
      mirror_with_rsync "$src" "$dst"
    else
      # fallback: tar copy (no excludes, but these are small roots)
      if have tar; then
        (cd "$src" 2>/dev/null && tar -cf - . 2>/dev/null) | (cd "$dst" 2>/dev/null && tar -xf - 2>/dev/null) || true
      else
        cp -a "$src/." "$dst/." 2>/dev/null || true
      fi
    fi
  done
}

mirror_extream_deep() {
  # Deep mirror can be huge. To avoid self-copy loops and explosions:
  # - WORK is placed in /tmp by default for extream
  # - We ONLY deep copy if rsync is available; otherwise create manifests.
  ensure_dir "$WORK/fs" || true
  if rsync_available; then
    for src in /storage /opt; do
      [ -d "$src" ] || continue
      dst="$WORK/fs$(printf '%s' "$src")"
      ensure_dir "$dst" || true
      mirror_with_rsync "$src" "$dst"
    done
  else
    for src in /storage /opt; do
      [ -d "$src" ] || continue
      out="$WORK/fs$(printf '%s' "$src").MANIFEST.tsv"
      mirror_manifest_only "$src" "$out"
    done
  fi
}

mirror_filesystems() {
  mirror_configs
  if [ "$MODE" = "extream" ]; then
    mirror_extream_deep
  fi
}

collect_entware() {
  ensure_dir "$WORK/entware" || true
  if have opkg; then
    opkg list-installed 2>/dev/null >"$WORK/entware/opkg_list_installed.txt" || true
    opkg status 2>/dev/null >"$WORK/entware/opkg_status.txt" || true
  fi
  # init.d services inventory
  if [ -d /opt/etc/init.d ]; then
    ensure_dir "$WORK/entware/init.d" || true
    ls -la /opt/etc/init.d 2>/dev/null >"$WORK/entware/initd_ls.txt" || true
  fi
}

collect_network() {
  ensure_dir "$WORK/net" || true
  (ip addr 2>/dev/null || ifconfig 2>/dev/null || true) >"$WORK/net/addr.txt" 2>/dev/null || true
  (ip route 2>/dev/null || route -n 2>/dev/null || true) >"$WORK/net/route.txt" 2>/dev/null || true
  if have ss; then
    ss -lntup 2>/dev/null >"$WORK/net/ss_listen.txt" || true
  else
    netstat -lntup 2>/dev/null >"$WORK/net/netstat_listen.txt" || true
  fi
  # derive listen_ports.tsv (best-effort)
  {
    echo "# proto\tip\tport\tstate\tsource"
    if have ss; then
      ss -lnt 2>/dev/null | awk 'NR>1 {print "tcp\t"$4"\tLISTEN\tss"}' | \
        sed -n 's/^\(tcp\)\t\([^:]*\):\([0-9][0-9]*\)\t.*/\1\t\2\t\3\tLISTEN\tss/p'
    elif have netstat; then
      netstat -lnt 2>/dev/null | awk 'NR>2 {print $1"\t"$4"\t"$6"\tnetstat"}' | \
        sed -n 's/^\(tcp\)\t\([^:]*\):\([0-9][0-9]*\)\tLISTEN\t.*/\1\t\2\t\3\tLISTEN\tnetstat/p'
    fi
  } >"$WORK/net/listen_ports.tsv" 2>/dev/null || true
}

http_fetch_status() {
  # args: scheme host port path -> code bytes note
  scheme="$1"; host="$2"; port="$3"; path="$4"
  url="${scheme}://${host}:${port}${path}"
  code="000"; bytes="0"; note=""
  if have curl; then
    out="$(curl -sk --max-time 3 -o /dev/null -w '%{http_code} %{size_download}' "$url" 2>/dev/null || true)"
    code="$(printf '%s' "$out" | awk '{print $1}' 2>/dev/null || echo 000)"
    bytes="$(printf '%s' "$out" | awk '{print $2}' 2>/dev/null || echo 0)"
  elif have wget; then
    # wget doesn't easily return code; do headers
    hdr="$(wget -qS --spider --timeout=3 "$url" 2>&1 | head -n 5 || true)"
    code="$(printf '%s' "$hdr" | sed -n 's/.*HTTP\/[0-9.]* \([0-9][0-9][0-9]\).*/\1/p' | head -n 1)"
    [ -n "$code" ] || code="000"
    bytes="0"
  fi
  printf '%s\t%s\t%s\t%s\t%s\t%s\t%s\n' "$(now_utc)" "$host" "$port" "$scheme" "$path" "$code" "$note"
}

collect_http_probe() {
  ensure_dir "$WORK/net" || true
  {
    echo "# ts_utc\thost\tport\tscheme\tpath\tcode\tnote"
    # default management ports
    for host in 127.0.0.1; do
      for port in 80 443 79 78 8081; do
        for scheme in http https; do
          # keep numeric ports only
          echo "$port" | grep -Eq '^[0-9]+$' || continue
          for path in / /auth /rci/ /rci/show/system /rci/show/version /ci/self-test.txt /ci/startup-config.txt; do
            http_fetch_status "$scheme" "$host" "$port" "$path"
          done
        done
      done
    done
  } >"$WORK/net/http_probe.tsv" 2>/dev/null || true
}

safe_name() {
  # replace any char not safe for filenames with _
  printf '%s' "$1" | sed 's/[^A-Za-z0-9._-]/_/g'
}

web_fetch_sample() {
  scheme="$1"; host="$2"; port="$3"; path="$4"; outdir="$5"
  ensure_dir "$outdir" || return 0
  url="${scheme}://${host}:${port}${path}"
  headers="$outdir/$(safe_name "$path").headers"
  body="$outdir/$(safe_name "$path").body"
  code="000"; bytes="0"
  if have curl; then
    # headers
    curl -sk --max-time 5 -D "$headers" -o "$body" --range 0-262143 "$url" 2>/dev/null || true
    code="$(awk 'NR==1{print $2}' "$headers" 2>/dev/null || echo 000)"
    bytes="$(wc -c <"$body" 2>/dev/null || echo 0)"
  fi
  printf '%s\t%s\t%s\t%s\t%s\t%s\t%s\n' "$(now_utc)" "$host" "$port" "$scheme" "$path" "${code:-000}" "${bytes:-0}"
}

collect_web_probe() {
  ensure_dir "$WORK/web" || true
  # Determine candidate ports: from listen_ports.tsv + defaults
  ports="80 443 79 78 8081"
  if [ -f "$WORK/net/listen_ports.tsv" ]; then
    p2="$(awk -F'\t' 'NR>1 {print $3}' "$WORK/net/listen_ports.tsv" 2>/dev/null | tr '\n' ' ' 2>/dev/null || true)"
    ports="$ports $p2"
  fi
  # sanitize ports: keep only digits, unique
  ports="$(printf '%s' "$ports" | tr -cd '0-9 \n' 2>/dev/null | tr '\n' ' ' 2>/dev/null)"
  # unique
  uniq_ports=""
  for p in $ports; do
    echo "$p" | grep -Eq '^[0-9]+$' || continue
    echo " $uniq_ports " | grep -q " $p " && continue
    uniq_ports="$uniq_ports $p"
  done

  paths="/ /robots.txt /api /metrics /swagger.json /openapi.json /rci/ /rci/show/system /rci/show/version"
  {
    echo "# ts_utc\thost\tport\tscheme\tpath\tcode\tbytes"
    for host in 127.0.0.1; do
      for port in $uniq_ports; do
        for scheme in http https; do
          # store samples under web/<host>_<port>_<scheme>/
          od="$WORK/web/$(safe_name "${host}_${port}_${scheme}")"
          for path in $paths; do
            web_fetch_sample "$scheme" "$host" "$port" "$path" "$od"
          done
        done
      done
    done
  } >"$WORK/web/probe.tsv" 2>/dev/null || true
}

collect_firewall() {
  ensure_dir "$WORK/net" || true
  (iptables-save 2>/dev/null || true) >"$WORK/net/iptables-save.txt" 2>/dev/null || true
  (nft list ruleset 2>/dev/null || true) >"$WORK/net/nft-ruleset.txt" 2>/dev/null || true
}

collect_ndmc() {
  ensure_dir "$WORK/ndm" || true
  if have ndmc; then
    ndmc -c 'show version' 2>/dev/null >"$WORK/ndm/show_version.txt" || true
    ndmc -c 'show system' 2>/dev/null >"$WORK/ndm/show_system.txt" || true
    ndmc -c 'show interface' 2>/dev/null >"$WORK/ndm/show_interface.txt" || true
    ndmc -c 'show log' 2>/dev/null >"$WORK/ndm/show_log.txt" || true
    ndmc -c 'show running-config' 2>/dev/null >"$WORK/ndm/show_running-config.txt" || true
    ndmc -c 'more flash:startup-config' 2>/dev/null >"$WORK/ndm/flash_startup-config.txt" || true
  fi
}

run_collectors_parallel() {
  # best-effort: run python analyzer later; here run optional language collectors
  ensure_dir "$WORK/tmp" || true
  # jobs
  cores="$(get_cores)"
  case "$JOBS" in
    auto) JOBS_N="$cores" ;;
    ''|*[!0-9]*) JOBS_N=1 ;;
    *) JOBS_N="$JOBS" ;;
  esac
  [ "$JOBS_N" -lt 1 ] && JOBS_N=1
  [ "$JOBS_N" -gt 4 ] && JOBS_N=4  # keep sane on routers

  # determine enabled collectors
  enabled="sh"
  case "$COLLECTORS" in
    all) enabled="sh py go lua node perl ruby" ;;
    shonly) enabled="sh" ;;
    shpy) enabled="sh py" ;;
    custom) enabled="sh $(printf '%s' "$CUSTOM_COLLECTORS" | tr ',' ' ')" ;;
  esac

  # run simple collectors if present
  pids=""
  running=0

  run_one() {
    name="$1"; cmd="$2"
    ( eval "$cmd" ) >>"$RUNLOG" 2>>"$ERRLOG" &
    pids="$pids $!"
    running=$((running + 1))
  }

  wait_one() {
    # wait for any one pid
    for pid in $pids; do
      if wait "$pid" 2>/dev/null; then :; fi
      # rebuild list without pid
      new=""
      for x in $pids; do [ "$x" = "$pid" ] && continue; new="$new $x"; done
      pids="$new"
      running=$((running - 1))
      break
    done
  }

  # collectors execute into WORK subdirs
  if echo " $enabled " | grep -q " py " && have python3 && [ -f "$COLLECTORS_DIR/py/analyze.py" ]; then
    # inventory json only (fast); report is later
    run_one "py-inv" "python3 '$COLLECTORS_DIR/py/analyze.py' --inventory --workdir '$WORK' >'$WORK/analysis/inventory.json' 2>/dev/null || true"
  fi

  # placeholder for other languages; keep best-effort
  # (their scripts can be added; they should write under WORK/)
  for lang in go lua node perl ruby; do
    echo " $enabled " | grep -q " $lang " || continue
    # if a runner exists, execute
    runner="$COLLECTORS_DIR/$lang/run.sh"
    if [ -f "$runner" ]; then
      run_one "$lang" "sh '$runner' '$WORK' || true"
    fi
    # throttle concurrency
    while [ "$running" -ge "$JOBS_N" ]; do
      wait_one
    done
  done

  # wait remaining
  for pid in $pids; do
    wait "$pid" 2>/dev/null || true
  done
}

scan_sensitive() {
  ensure_dir "$WORK/analysis" || true
  out="$WORK/analysis/SENSITIVE_LOCATIONS.md"
  {
    echo "# Sensitive locations (best-effort)"
    echo
    echo "Этот файл показывает *места*, где вероятны секреты (пароли/ключи/токены)."
    echo "Значения не выводятся, только пути и строки/паттерны."
    echo
    echo "## Candidates"
    echo
  } >"$out" 2>/dev/null || true

  # scan limited trees (fs mirror + ndm)
  roots=""
  [ -d "$WORK/fs" ] && roots="$roots $WORK/fs"
  [ -d "$WORK/ndm" ] && roots="$roots $WORK/ndm"

  for r in $roots; do
    # avoid binary spam: only text-like extensions
    find "$r" -type f \( \
      -name '*.conf' -o -name '*.cfg' -o -name '*.ini' -o -name '*.json' -o -name '*.yaml' -o -name '*.yml' -o -name '*.sh' -o -name '*.txt' \
      \) 2>/dev/null | head -n 20000 | while IFS= read -r f; do
      # grep patterns (bounded)
      grep -nE '(password|passwd|secret|token|api[_-]?key|private[_-]?key|BEGIN [A-Z ]*PRIVATE KEY)' "$f" 2>/dev/null | head -n 5 | while IFS= read -r line; do
        printf -- '- `%s`: `%s`\n' "$(printf '%s' "$f" | sed "s|$WORK/||")" "$(printf '%s' "$line" | sed 's/`/\\`/g')" >>"$out" 2>/dev/null || true
      done
    done
  done
}

write_redaction_guides() {
  ensure_dir "$WORK/analysis" || true
  ru="$WORK/analysis/REDACTION_GUIDE_RU.md"
  en="$WORK/analysis/REDACTION_GUIDE_EN.md"
  cat >"$ru" <<'EOF'
# Как скрыть чувствительные данные перед отправкой

1) Открой `analysis/SENSITIVE_LOCATIONS.md` и пройдись по перечисленным файлам/строкам.
2) Секреты обычно находятся в:
- `/opt/etc/*`
- `/storage/etc/*`
- `startup-config` / `running-config`
- файлах бота (tokens)
3) Перед отправкой архива:
- либо вручную отредактируй файлы в распакованной папке и пересобери архив
- либо используй SAFE режим: `--mode safe` (если включён в вашей версии)

EOF
  cat >"$en" <<'EOF'
# How to redact sensitive data before sharing

1) Open `analysis/SENSITIVE_LOCATIONS.md` and review listed files/lines.
2) Secrets are commonly located in:
- `/opt/etc/*`
- `/storage/etc/*`
- `startup-config` / `running-config`
- bot config files (tokens)
3) Before sharing the archive:
- manually edit files in the extracted folder and re-pack
- or use SAFE mode: `--mode safe` (if available)

EOF
}

generate_reports() {
  ensure_dir "$WORK/analysis" || true
  # Prefer python report if python3 exists
  if have python3 && [ -f "$COLLECTORS_DIR/py/analyze.py" ]; then
    python3 "$COLLECTORS_DIR/py/analyze.py" --report --workdir "$WORK" >>"$RUNLOG" 2>>"$ERRLOG" || true
    return 0
  fi

  # minimal report
  ru="$WORK/analysis/REPORT_RU.md"
  en="$WORK/analysis/REPORT_EN.md"
  cat >"$ru" <<EOF
# Отчёт keenetic-maxprobe (минимальный)

Python3 не найден, поэтому этот отчёт — минимальный (shell-only).

Смотрите:
- \`meta/run.log\`
- \`meta/errors.log\`
- \`fs/\`
- \`ndm/\`
- \`net/\` и \`web/\`

Архив: $(basename "$ARCHIVE")
EOF
  cat >"$en" <<EOF
# keenetic-maxprobe report (minimal)

python3 was not found, so this is a minimal shell-only report.

See:
- \`meta/run.log\`
- \`meta/errors.log\`
- \`fs/\`
- \`ndm/\`
- \`net/\` and \`web/\`

Archive: $(basename "$ARCHIVE")
EOF
}

pack_archive() {
  set_phase "Packing archive"
  gzip_cmd="gzip -1"
  if have nice; then gzip_cmd="nice -n 19 gzip -1"; fi
  # ensure archive name doesn't end up with empty timestamp
  ensure_dir "$OUTBASE" || true
  (cd "$WORK" 2>/dev/null && tar -cf - . 2>/dev/null) | sh -c "$gzip_cmd" >"$ARCHIVE" 2>/dev/null || die "Failed to create archive"
  if have sha256sum; then
    (cd "$OUTBASE" 2>/dev/null && sha256sum "$(basename "$ARCHIVE")" >"$(basename "$ARCHIVE").sha256") 2>/dev/null || true
  fi
}

cleanup_workdir() {
  set_phase "Cleanup workdir"
  rm -rf "$WORK" 2>/dev/null || true
}

# ---------------- main ----------------
main() {
  load_config
  parse_args "$@"

  case "$LANG_UI" in ru|en) : ;; *) LANG_UI="ru" ;; esac
  case "$MODE" in full|safe|extream) : ;; *) MODE="full" ;; esac
  case "$PROFILE" in auto|forensic|diagnostic|lite) : ;; *) PROFILE="auto" ;; esac

  if [ "$INIT" -eq 1 ]; then
    init_wizard
    exit 0
  fi

  OUTBASE="$(pick_outdir)"
  check_free_space_warn || true

  clean_tmp_dir || true
  clean_old_outputs || true

  host="$(hostname 2>/dev/null || cat /proc/sys/kernel/hostname 2>/dev/null || echo keenetic)"
  # IMPORTANT: use coreutils tr, not i18n function
  ts="$(now_utc | command tr ':' '-' 2>/dev/null | command tr ' ' '_' 2>/dev/null)"
  [ -n "$ts" ] || ts="$(date +%s 2>/dev/null || echo 0)"
  BASE="keenetic-maxprobe-${host}-$$-${ts}"

  # WORKDIR strategy:
  # - for extream: work in /tmp to avoid self-mirror under /opt or /storage
  if [ "$MODE" = "extream" ]; then
    WORK="/tmp/${BASE}.work"
  else
    WORK="$OUTBASE/${BASE}.work"
  fi

  ARCHIVE="$OUTBASE/${BASE}.tar.gz"

  ensure_dir "$WORK" || die "Cannot create workdir: $WORK"
  for d in meta analysis ndm entware net web sys fs tmp; do ensure_dir "$WORK/$d" || true; done

  RUNLOG="$WORK/meta/run.log"
  ERRLOG="$WORK/meta/errors.log"
  : >"$RUNLOG" 2>/dev/null || true
  : >"$ERRLOG" 2>/dev/null || true

  PHASE_FILE="$WORK/meta/phase.txt"
  PROGRESS_FILE="$WORK/meta/progress.txt"
  printf '%s\n' "0/0" >"$PROGRESS_FILE" 2>/dev/null || true
  printf '%s\n' "starting..." >"$PHASE_FILE" 2>/dev/null || true

  START_EPOCH="$(date +%s 2>/dev/null || echo 0)"
  trap 'stop_spinner 2>/dev/null || true; stop_metrics 2>/dev/null || true' INT TERM EXIT

  # steps
  TOTAL_STEPS=14
  STEP_NO=0
  set_progress

  start_metrics || true
  start_spinner || true
  say "$(T STARTING)"

  maybe_install_collectors_runtimes || true

  step "Meta: basic info"
  collect_meta

  step "System: /proc snapshots"
  collect_proc

  step "System: commands"
  collect_sys_commands

  step "Filesystem: mirror configs"
  mirror_filesystems

  step "Entware: inventory"
  collect_entware

  step "Network: snapshots"
  collect_network

  step "Network: HTTP/RCI probe"
  collect_http_probe

  if [ "$MODE" = "full" ] || [ "$MODE" = "extream" ]; then
    step "Web: extended probe"
    collect_web_probe
  fi

  step "Firewall: snapshot"
  collect_firewall

  step "KeeneticOS: ndmc snapshots"
  collect_ndmc

  step "Collectors: optional languages"
  run_collectors_parallel

  step "Analysis: sensitive map"
  scan_sensitive

  step "Analysis: redaction guides"
  write_redaction_guides

  step "Analysis: reports"
  generate_reports

  step "Cleanup: temp packages"
  cleanup_temp_packages

  step "Packing: archive"
  pack_archive

  stop_spinner || true
  stop_metrics || true

  say "$(T DONE) $ARCHIVE"
  cleanup_workdir || true
}

main "$@"
