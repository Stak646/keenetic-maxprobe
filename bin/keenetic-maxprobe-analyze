#!/usr/bin/env python3
"""
keenetic-maxprobe-analyze
Generates human-readable RU/EN reports + machine-readable JSON from a maxprobe bundle.
No network calls. Works offline.
"""
from __future__ import annotations
import json, re, sys
from pathlib import Path
from datetime import datetime, timezone
import ipaddress

def read_text(p: Path) -> str:
    try:
        return p.read_text(encoding="utf-8", errors="ignore")
    except Exception:
        return ""

def find_exit_code(text: str) -> int | None:
    m = re.search(r"^# exit_code:\s*(\d+)\s*$", text, re.M)
    return int(m.group(1)) if m else None

def parse_netstat(text: str):
    # Very tolerant parser for busybox/net-tools outputs
    listeners = []
    for line in text.splitlines():
        line = line.strip()
        if not (line.startswith("tcp") or line.startswith("udp")):
            continue
        parts = re.split(r"\s+", line)
        if len(parts) < 4:
            continue
        proto = parts[0]
        local = parts[3]
        state = ""
        pidprog = ""
        if proto.startswith("tcp") and len(parts) >= 7:
            state = parts[5]
            pidprog = parts[6]
            if state != "LISTEN":
                continue
        elif proto.startswith("udp") and len(parts) >= 6:
            pidprog = parts[5]
        if ":" not in local:
            continue
        addr, port_s = local.rsplit(":", 1)
        if not port_s.isdigit():
            continue
        port = int(port_s)
        prog = pidprog.split("/", 1)[1] if "/" in pidprog else pidprog
        listeners.append({"proto": proto, "addr": addr, "port": port, "program": prog})
    return listeners

def parse_http_probe(text: str):
    # Our probe writes sections like: ## host:port/path (http)
    out = []
    cur = None
    for line in text.splitlines():
        if line.startswith("## "):
            m = re.match(r"^##\s+(.+?):(\d+)(/[^ ]*)\s+\((https?)\)\s*$", line.strip())
            if m:
                if cur: out.append(cur)
                cur = {"host": m.group(1), "port": int(m.group(2)), "path": m.group(3), "scheme": m.group(4), "status": None, "detail": None}
            continue
        if cur and cur["status"] is None and line.startswith("HTTP/"):
            cur["status"] = line.strip()
            continue
        if cur and cur["detail"] is None and line.lower().startswith("x-detail:"):
            cur["detail"] = line.split(":", 1)[1].strip()
            continue
    if cur: out.append(cur)
    return out

def md_escape(s: str) -> str:
    return s.replace("\\", "\\\\").replace("`", "\\`")

def summarize_endpoints(listeners, probe_rows):
    # Identify likely Keenetic web server entries (program==null) and app servers
    key: dict[str, list[str]] = {}
    tmp: dict[tuple[str,int], set[str]] = {}
    for x in listeners:
        tmp.setdefault((x["program"], x["port"]), set()).add(x["addr"])
    for (prog, port), addrs in tmp.items():
        key[f"{prog}:{port}"] = sorted(addrs)
    return key

def get_ndm_cmd_results(outdir: Path):
    ndm = outdir / "ndm"
    results = []
    if not ndm.exists():
        return results
    for p in sorted(ndm.glob("*.txt")):
        txt = read_text(p)
        rc = find_exit_code(txt)
        results.append({"file": p.name, "exit_code": rc})
    return results

def get_hooks(outdir: Path):
    hooks_dir = outdir / "hooks"
    trees = sorted(hooks_dir.glob("*_tree.txt"))
    hook_files = []
    for t in trees:
        txt = read_text(t)
        base = None
        # base dir is in the command line but we can infer from filename
        base = t.stem.replace("_tree","").replace("opt_etc_ndm","/opt/etc/ndm").replace("storage_etc_ndm","/storage/etc/ndm")
        entries=[]
        for line in txt.splitlines():
            if line.startswith("/") and "\t" in line:
                parts = line.split("\t")
                if len(parts) >= 2:
                    entries.append({"path": parts[0], "type": parts[1]})
        hook_files.extend([e["path"] for e in entries if e["type"] == "f"])
    # Keep only unique and sort
    hook_files = sorted(set(hook_files))
    # Directories names for known events
    event_dirs = sorted({Path(p).parent.name for p in hook_files if ".d" in p})
    return {"hook_files": hook_files, "event_dirs_with_scripts": event_dirs}

def get_services(outdir: Path):
    p = outdir / "entware" / "init_d_list.txt"
    txt = read_text(p)
    services = []
    for line in txt.splitlines():
        line=line.strip()
        if not line.startswith("-") and not line.startswith("d"):
            continue
        parts = re.split(r"\s+", line)
        if len(parts) < 9:
            continue
        name = parts[-1]
        if name.startswith("S") and name[1:3].isdigit():
            services.append(name)
    return sorted(set(services))

def main():
    if len(sys.argv) < 2:
        print("Usage: keenetic-maxprobe-analyze <bundle_dir>")
        return 2
    outdir = Path(sys.argv[1]).expanduser().resolve()
    if not outdir.exists():
        print(f"Not found: {outdir}")
        return 2

    netstat = parse_netstat(read_text(outdir / "net" / "netstat_listen.txt"))
    probe = parse_http_probe(read_text(outdir / "api" / "http_probe.txt"))
    ndm_cmds = get_ndm_cmd_results(outdir)
    hooks = get_hooks(outdir)
    services = get_services(outdir)

    endpoint_map = summarize_endpoints(netstat, probe)

    # Build a short, actionable summary in structured JSON
    summary = {
        "generated_utc": datetime.now(timezone.utc).isoformat(),
        "bundle": outdir.name,
        "listeners": endpoint_map,
        "http_probe_hits": [r for r in probe if r.get("status")],
        "ndm_cmd_results": ndm_cmds,
        "hook_scripts": hooks["hook_files"],
        "entware_init_scripts": services,
    }

    (outdir / "analysis").mkdir(exist_ok=True)

    (outdir / "analysis" / "summary.json").write_text(json.dumps(summary, indent=2, ensure_ascii=False), encoding="utf-8")

    # Determine key findings for this router
    # 1) Keenetic web server presence
    mgmt_ports = sorted({int(k.split(':',1)[1]) for k in endpoint_map.keys() if k.startswith('null:')})
    lighttpd_ports = sorted({int(k.split(':',1)[1]) for k in endpoint_map.keys() if k.startswith('lighttpd:')})
    awg_ports = sorted({int(k.split(':',1)[1]) for k in endpoint_map.keys() if k.startswith('awg-manager:')})
    hrweb_ports = sorted({int(k.split(':',1)[1]) for k in endpoint_map.keys() if k.startswith('hrweb:')})
    dropbear_ports = sorted({int(k.split(':',1)[1]) for k in endpoint_map.keys() if k.startswith('dropbear:')})

    # 2) Probe statuses for /auth and /rci/
    def probe_status(path: str):
        hits=[r for r in probe if r["path"]==path and r.get("status")]
        # return representative statuses by scheme+port
        out=[]
        for r in hits:
            out.append({"host": r["host"], "port": r["port"], "scheme": r["scheme"], "status": r["status"], "detail": r.get("detail")})
        return out

    auth_hits = probe_status("/auth")
    rci_hits  = probe_status("/rci/")

    # 3) NDM commands that succeeded/failed
    ok = sorted([x["file"] for x in ndm_cmds if x["exit_code"] == 0])
    bad = sorted([x for x in ndm_cmds if x["exit_code"] not in (0, None)], key=lambda z:z["file"])

    # RU report
    ru = []
    ru.append(f"# Отчёт keenetic-maxprobe (bundle: `{md_escape(outdir.name)}`)\n")
    ru.append("## 1) Доступные порты/сервисы (по `netstat`)\n")
    if dropbear_ports:
        ru.append(f"- SSH (dropbear): порты {', '.join(map(str, dropbear_ports))}\n")
    if mgmt_ports:
        ru.append(f"- Web-интерфейс KeeneticOS (процесс `null`): порты {', '.join(map(str, mgmt_ports))}\n")
    if lighttpd_ports:
        ru.append(f"- Entware lighttpd: порты {', '.join(map(str, lighttpd_ports))}\n")
    if hrweb_ports:
        ru.append(f"- hrweb: порты {', '.join(map(str, hrweb_ports))}\n")
    if awg_ports:
        ru.append(f"- awg-manager: порты {', '.join(map(str, awg_ports))}\n")
    ru.append("\n**Примечание по безопасности:** в bundle видно, что web-интерфейс KeeneticOS слушает не только LAN-адреса, но и WAN/туннельные адреса (если включён удалённый доступ). Это стоит перепроверить в настройках удалённого управления.\n")

    ru.append("## 2) API-эндпойнты управления (web/RCI)\n")
    ru.append("В пробе без аутентификации обнаружено, что `/auth` и `/rci/` отвечают (то есть эндпойнты существуют), но на HTTP запросы возвращают **403** с признаком `insufficient security level` (нужно HTTPS/повышенный уровень сессии/аутентификация).\n")
    if auth_hits:
        ru.append("Примеры ответов на `/auth`:\n")
        for h in auth_hits[:8]:
            det = f", X-Detail: {h['detail']}" if h.get("detail") else ""
            ru.append(f"- {h['scheme']}://{h['host']}:{h['port']}/auth -> {h['status']}{det}\n")
    if rci_hits:
        ru.append("\nПримеры ответов на `/rci/`:\n")
        for h in rci_hits[:8]:
            det = f", X-Detail: {h['detail']}" if h.get("detail") else ""
            ru.append(f"- {h['scheme']}://{h['host']}:{h['port']}/rci/ -> {h['status']}{det}\n")
    ru.append("\n**Рекомендация для Telegram-бота на роутере:** базово дергать управление через `ndmc` (локально, без хранения пароля), а RCI использовать как опциональный backend (если включён HTTPS и есть учётка/токен).\n")

    ru.append("## 3) Единый слой управления Entware-службами\n")
    ru.append("В Entware обнаружены init-скрипты:\n")
    for s in services:
        ru.append(f"- `/opt/etc/init.d/{s}`\n")
    ru.append("\n**Практичный интерфейс для бота:**\n")
    ru.append("- `list` → список сервисов\n- `status <svc>` → попытка `... status`, иначе проверка процесса по `ps`\n- `start|stop|restart <svc>` → вызов init-скрипта\n- `logs <svc>` → хвост `/opt/var/log/*` + syslog/`ndmc show log`\n")
    ru.append("\n(В самом репозитории инструмента стоит держать маленький helper `entwarectl` и вызывать его из бота.)\n")

    ru.append("## 4) Реальные event-хуки (OPKG-компонент)\n")
    if hooks["hook_files"]:
        ru.append("В hook-деревьях найдены реальные скрипты:\n")
        for f in hooks["hook_files"]:
            ru.append(f"- `{md_escape(f)}`\n")
    else:
        ru.append("Скриптов в hook-деревьях не найдено.\n")

    ru.append("\n### Предлагаемая схема уведомлений в Telegram\n")
    ru.append("Лучше всего сделать **единый событийный шлюз**:\n")
    ru.append("1) Любой hook-скрипт пишет событие JSON в `/opt/var/spool/keenetic-events/` (один файл = одно событие).\n")
    ru.append("2) Telegram-бот (сервис Entware) читает spool и отправляет сообщения.\n")
    ru.append("3) Hook-скрипты остаются максимально простыми и не содержат токенов Telegram.\n\n")
    ru.append("Минимальный набор событий:\n")
    ru.append("- `wan.d` / `iflayerchanged.d` / `ifstatechanged.d` → WAN up/down\n")
    ru.append("- `ifipchanged.d` / `ifip6changed.d` → смена IP\n")
    ru.append("- `netfilter.d` → обновление iptables (firewall refresh)\n")
    ru.append("- `usb.d` → подключение/отключение USB\n")
    ru.append("- `time.d` → синхронизация времени\n")

    ru.append("## 5) Карта команд/состояний KeeneticOS (что лучше дергать)\n")
    ru.append("По результатам выполнения команд `ndmc`:\n")
    if ok:
        ru.append("\nУспешно выполнены (exit_code=0):\n")
        for f in ok:
            ru.append(f"- `{f}`\n")
    if bad:
        ru.append("\nКоманды, которые вернули ошибку (полезно учитывать в переносимости):\n")
        for x in bad:
            ru.append(f"- `{x['file']}` → exit_code={x['exit_code']}\n")
    ru.append("\n**Рекомендованный минимум для polling (бот/мониторинг):**\n")
    ru.append("- `show system` (аптайм/ресурсы)\n- `show interface` (состояния портов/WAN)\n- `show ip route` / `show ip policy`\n- `show log` (по необходимости)\n- `components list` (для определения доступных функций)\n")
    ru.append("\n**Для действий (mutating):** лучше строить отдельный слой команд `ndmc -c '<cmd>'`, но перечень конкретных mutate-команд лучше формировать после выгрузки полного `ndm/help.txt` на твоей сборке.\n")

    (outdir / "analysis" / "REPORT_RU.md").write_text("".join(ru), encoding="utf-8")

    # EN report (shorter but complete)
    en = []
    en.append(f"# keenetic-maxprobe report (bundle: `{md_escape(outdir.name)}`)\n")
    en.append("## 1) Listening ports/services (from `netstat`)\n")
    if dropbear_ports:
        en.append(f"- SSH (dropbear): ports {', '.join(map(str, dropbear_ports))}\n")
    if mgmt_ports:
        en.append(f"- KeeneticOS web UI (`null`): ports {', '.join(map(str, mgmt_ports))}\n")
    if lighttpd_ports:
        en.append(f"- Entware lighttpd: ports {', '.join(map(str, lighttpd_ports))}\n")
    if hrweb_ports:
        en.append(f"- hrweb: ports {', '.join(map(str, hrweb_ports))}\n")
    if awg_ports:
        en.append(f"- awg-manager: ports {', '.join(map(str, awg_ports))}\n")
    en.append("\nSecurity note: the bundle suggests KeeneticOS web UI may be bound to WAN/tunnel addresses as well (if remote management is enabled). Verify remote access settings.\n")

    en.append("## 2) Management API endpoints (web/RCI)\n")
    en.append("Unauthenticated probing shows `/auth` and `/rci/` respond (endpoints exist), but return **403** with `insufficient security level` for plain HTTP requests (HTTPS / higher session security / authentication likely required).\n")
    if auth_hits:
        en.append("Sample `/auth` responses:\n")
        for h in auth_hits[:8]:
            det = f", X-Detail: {h['detail']}" if h.get("detail") else ""
            en.append(f"- {h['scheme']}://{h['host']}:{h['port']}/auth -> {h['status']}{det}\n")
    if rci_hits:
        en.append("\nSample `/rci/` responses:\n")
        for h in rci_hits[:8]:
            det = f", X-Detail: {h['detail']}" if h.get("detail") else ""
            en.append(f"- {h['scheme']}://{h['host']}:{h['port']}/rci/ -> {h['status']}{det}\n")
    en.append("\nRecommendation for an on-router Telegram bot: use `ndmc` as the primary backend (local, no password storage) and keep RCI optional.\n")

    en.append("## 3) Unified Entware service control layer\n")
    en.append("Detected init scripts:\n")
    for s in services:
        en.append(f"- `/opt/etc/init.d/{s}`\n")
    en.append("\nSuggested bot API:\n- list services\n- start/stop/restart\n- status (call script if supported, otherwise `ps` fallback)\n- logs (tail `/opt/var/log/*` plus `ndmc show log`)\n")

    en.append("## 4) Real OPKG component event hooks\n")
    if hooks["hook_files"]:
        en.append("Hook scripts found:\n")
        for f in hooks["hook_files"]:
            en.append(f"- `{md_escape(f)}`\n")
    en.append("\nProposed Telegram notification architecture: hook scripts write JSON events into a spool directory, bot consumes and sends messages. Keep Telegram tokens out of hook scripts.\n")

    en.append("## 5) KeeneticOS CLI command/state map\n")
    if ok:
        en.append("\nSucceeded (exit_code=0):\n")
        for f in ok:
            en.append(f"- `{f}`\n")
    if bad:
        en.append("\nFailed (portability considerations):\n")
        for x in bad:
            en.append(f"- `{x['file']}` -> exit_code={x['exit_code']}\n")
    en.append("\nRecommended polling set:\n- `show system`\n- `show interface`\n- `show ip route` / `show ip policy`\n- `show log` (as needed)\n- `components list`\n")
    (outdir / "analysis" / "REPORT_EN.md").write_text("".join(en), encoding="utf-8")

    return 0

if __name__ == "__main__":
    raise SystemExit(main())
