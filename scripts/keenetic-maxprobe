#!/bin/sh
# keenetic-maxprobe — maximal KeeneticOS + Entware probe (FULL by default)
# Version: 0.4.1
set -u

VERSION="0.4.1"
PROG="keenetic-maxprobe"

# Prefer Entware first
PATH="/opt/bin:/opt/sbin:/usr/sbin:/usr/bin:/sbin:/bin:$PATH"
umask 077

MODE="full"         # full|safe  (FULL default)
PROFILE="forensic"  # forensic|diagnostic (forensic default)
COLLECTORS="all"    # comma-list or "all" or "auto"
OUTDIR=""
CLEAN_OLD=0
CLEAN_TMP=0
INIT=0
YES=0
NO_INSTALL=0

CONFIG_PATH="/opt/etc/keenetic-maxprobe.conf"
SHARE_DIR="/opt/share/keenetic-maxprobe"
COLLECTORS_DIR="$SHARE_DIR/collectors"

now_utc() { date -u '+%Y-%m-%dT%H:%M:%SZ' 2>/dev/null || date '+%Y-%m-%dT%H:%M:%SZ'; }
have() { command -v "$1" >/dev/null 2>&1; }
log() { printf '%s %s\n' "$(now_utc)" "$*" >&2; }

usage() {
cat <<'USAGE'
keenetic-maxprobe [options]

Options:
  --init
  --mode {full|safe}
  --profile {forensic|diagnostic}
  --collectors <all|auto|sh,python,perl,lua,ruby,node,go>
  --outdir <dir>
  --clean-old
  --clean-tmp
  --no-install      (do not install dependencies via opkg)
  -y                (non-interactive defaults)

Examples:
  keenetic-maxprobe
  keenetic-maxprobe --mode safe --profile diagnostic --collectors sh,python
USAGE
}

ask_yn() {
  prompt="$1"
  def="$2"  # y/n
  if [ "$YES" -eq 1 ]; then
    [ "$def" = "y" ] && return 0 || return 1
  fi
  while :; do
    printf "%s [y/n] (default %s): " "$prompt" "$def" >&2
    read ans || ans=""
    [ -z "$ans" ] && ans="$def"
    case "$ans" in
      y|Y|yes) return 0 ;;
      n|N|no) return 1 ;;
    esac
  done
}

pick_outdir() {
  for d in /opt/var/tmp /opt/tmp /tmp; do
    if [ -d "$d" ] && [ -w "$d" ]; then
      echo "$d"
      return 0
    fi
  done
  echo "/tmp"
}

load_config() {
  [ -f "$CONFIG_PATH" ] || return 0
  # shellcheck disable=SC1090
  . "$CONFIG_PATH" 2>/dev/null || true
  MODE="${MODE:-full}"
  PROFILE="${PROFILE:-forensic}"
  COLLECTORS="${COLLECTORS:-all}"
  OUTDIR="${OUTDIR:-}"
}

save_config() {
  mkdir -p "$(dirname "$CONFIG_PATH")" 2>/dev/null || true
  cat >"$CONFIG_PATH" <<EOF
MODE="$MODE"
PROFILE="$PROFILE"
COLLECTORS="$COLLECTORS"
OUTDIR="$OUTDIR"
EOF
}

init_wizard() {
  log "Mode: 1) FULL (default) 2) SAFE"
  printf "Choice [1/2] (default 1): " >&2
  read m || m=""
  [ -z "$m" ] && m="1"
  [ "$m" = "2" ] && MODE="safe" || MODE="full"

  log "Profile: 1) forensic (default) 2) diagnostic"
  printf "Choice [1/2] (default 1): " >&2
  read p || p=""
  [ -z "$p" ] && p="1"
  [ "$p" = "2" ] && PROFILE="diagnostic" || PROFILE="forensic"

  log "Collectors:"
  log "  1) all (default, best-effort)"
  log "  2) sh only"
  log "  3) sh+python"
  log "  4) sh+python+perl+lua+ruby+node"
  log "  5) custom list (comma-separated)"
  printf "Choice [1-5] (default 1): " >&2
  read c || c=""
  [ -z "$c" ] && c="1"
  case "$c" in
    2) COLLECTORS="sh" ;;
    3) COLLECTORS="sh,python" ;;
    4) COLLECTORS="sh,python,perl,lua,ruby,node" ;;
    5)
      printf "Enter collectors list (e.g. sh,python,go): " >&2
      read cl || cl=""
      [ -n "$cl" ] && COLLECTORS="$cl" || COLLECTORS="all"
      ;;
    *) COLLECTORS="all" ;;
  esac

  printf "OUTDIR (empty for auto): " >&2
  read o || o=""
  OUTDIR="$o"

  ask_yn "Clean old keenetic-maxprobe-* in OUTDIR?" "n" && CLEAN_OLD=1 || true
  ask_yn "Clean /tmp before run? (dangerous)" "n" && CLEAN_TMP=1 || true

  save_config
  log "Saved config: $CONFIG_PATH"
}

# args
while [ $# -gt 0 ]; do
  case "$1" in
    --init) INIT=1 ;;
    --mode) MODE="$2"; shift ;;
    --profile) PROFILE="$2"; shift ;;
    --collectors) COLLECTORS="$2"; shift ;;
    --outdir) OUTDIR="$2"; shift ;;
    --clean-old) CLEAN_OLD=1 ;;
    --clean-tmp) CLEAN_TMP=1 ;;
    --no-install) NO_INSTALL=1 ;;
    -y) YES=1 ;;
    -h|--help) usage; exit 0 ;;
    *) log "Unknown arg: $1"; usage; exit 2 ;;
  esac
  shift
done

load_config
[ "$INIT" -eq 1 ] && init_wizard

case "$MODE" in full|safe) : ;; *) log "Bad --mode"; exit 2;; esac
case "$PROFILE" in forensic|diagnostic) : ;; *) log "Bad --profile"; exit 2;; esac

if [ -z "${OUTDIR:-}" ]; then
  OUTDIR="$(pick_outdir)"
fi
[ -n "$OUTDIR" ] || OUTDIR="/tmp"

HOST="$(hostname 2>/dev/null | tr -cd 'A-Za-z0-9._-' | head -c 64)"
[ -z "$HOST" ] && HOST="keenetic"
TS="$(date -u +%Y-%m-%dT%H-%M-%SZ 2>/dev/null || date +%Y-%m-%dT%H-%M-%SZ)"
WORK="$OUTDIR/${PROG}-${HOST}-${TS}"
ARCHIVE="$OUTDIR/${PROG}-${HOST}-${TS}.tar.gz"

mkdir -p "$WORK"/{analysis,meta,ndm,entware,net,sys,fs,tmp} 2>/dev/null || true

LOGFILE="$WORK/meta/run.log"
ERRFILE="$WORK/meta/errors.log"

logf() { printf '%s %s\n' "$(now_utc)" "$*" >>"$LOGFILE" 2>/dev/null || true; }
errf() { printf '%s %s\n' "$(now_utc)" "$*" >>"$ERRFILE" 2>/dev/null || true; logf "$*"; }

cleanup() {
  rm -rf "$WORK" 2>/dev/null || true
}
trap cleanup EXIT INT TERM

if [ "$CLEAN_OLD" -eq 1 ]; then
  rm -rf "$OUTDIR/${PROG}-${HOST}-"* 2>/dev/null || true
fi
if [ "$CLEAN_TMP" -eq 1 ]; then
  find /tmp -mindepth 1 -maxdepth 1 2>/dev/null | while read -r p; do
    rm -rf "$p" 2>/dev/null || true
  done
fi

run_cmd() {
  out="$1"; shift
  {
    echo "### $PROG $VERSION"
    echo "### utc: $(now_utc)"
    echo "### cmd: $*"
    echo
    if have timeout; then
      timeout 60s "$@" || true
    else
      "$@" || true
    fi
    echo
  } >"$out" 2>&1
}

run_sh() {
  out="$1"; shift
  run_cmd "$out" sh -c "$*"
}

relpath() { echo "${1#/}"; }

copy_path() {
  src="$1"
  [ -e "$src" ] || return 0
  rel="$(relpath "$src")"
  dst="$WORK/fs/$rel"
  mkdir -p "$(dirname "$dst")" 2>/dev/null || true
  cp -a "$src" "$dst" 2>/dev/null || cp -R "$src" "$dst" 2>/dev/null || true
}

# ---- meta ----
run_sh "$WORK/meta/platform.txt" 'uname -a; echo; busybox 2>/dev/null | head -n 5; echo; id; echo; umask'
run_sh "$WORK/meta/opkg_arch.txt" 'opkg print-architecture 2>/dev/null || true'
run_sh "$WORK/meta/interpreters.txt" 'for x in sh busybox ndmc opkg python3 perl lua ruby node go; do command -v $x 2>/dev/null && $x --version 2>&1 | head -n 2; done || true'

# ---- dependency mgmt (best-effort) ----
BASE_PKGS="$WORK/meta/opkg_installed_before.txt"
ADDED_PKGS="$WORK/meta/opkg_installed_by_tool.txt"

list_installed_pkgs() {
  opkg list-installed 2>/dev/null | awk '{print $1}' | sort -u
}

opkg_has_pkg() {
  pkg="$1"
  opkg status "$pkg" 2>/dev/null | grep -q '^Package: ' && return 0
  return 1
}

opkg_try_install() {
  pkg="$1"
  if opkg_has_pkg "$pkg"; then return 0; fi
  opkg install "$pkg" >/dev/null 2>&1 && return 0
  return 1
}

install_cmd_if_missing() {
  cmd="$1"
  shift
  have "$cmd" && return 0
  [ "$NO_INSTALL" -eq 1 ] && return 1
  have opkg || return 1
  for pkg in "$@"; do
    opkg_try_install "$pkg" && return 0
  done
  return 1
}

if have opkg && [ "$NO_INSTALL" -eq 0 ]; then
  list_installed_pkgs >"$BASE_PKGS" 2>/dev/null || true
  opkg update >/dev/null 2>&1 || true

  install_cmd_if_missing curl curl ca-bundle || true
  install_cmd_if_missing wget wget-ssl wget-nossl ca-bundle || true
  install_cmd_if_missing ss ip-full ip || true
  install_cmd_if_missing netstat net-tools || true
  install_cmd_if_missing sha256sum coreutils-sha256sum coreutils || true
  install_cmd_if_missing stat coreutils-stat coreutils || true
  install_cmd_if_missing timeout coreutils-timeout coreutils || true
  install_cmd_if_missing find findutils coreutils-findutils || true
  install_cmd_if_missing tar tar || true
  install_cmd_if_missing gzip gzip || true

  install_cmd_if_missing iptables iptables || true
  install_cmd_if_missing nft nftables || true
  install_cmd_if_missing python3 python3 python3-light || true
  install_cmd_if_missing perl perl || true
  install_cmd_if_missing lua lua || true
  install_cmd_if_missing ruby ruby || true
  install_cmd_if_missing node node || true
  install_cmd_if_missing go go || true

  AFTER="$WORK/meta/opkg_installed_after.txt"
  list_installed_pkgs >"$AFTER" 2>/dev/null || true
  if have comm; then
    comm -13 "$BASE_PKGS" "$AFTER" >"$ADDED_PKGS" 2>/dev/null || true
  else
    awk 'NR==FNR{a[$1]=1;next}!a[$1]{print $1}' "$BASE_PKGS" "$AFTER" >"$ADDED_PKGS" 2>/dev/null || true
  fi
else
  echo "# opkg not used or --no-install enabled" >"$ADDED_PKGS" 2>/dev/null || true
fi

# ---- core collection ----
if have ndmc; then
  for cmd in     "show version"     "show system"     "show interface"     "show ip route"     "show ip policy"     "show log"     "components list"     "help"     "show running-config"     "more flash:startup-config"     "more flash:startup-config-default"     "more flash:startup-config.old"     ; do
    fn="$(echo "$cmd" | tr ' /:' '___')"
    run_cmd "$WORK/ndm/$fn.txt" ndmc -c "$cmd"
  done
fi

for p in   /etc   /storage/etc   /opt/etc   /opt/var/log   /opt/etc/init.d   /opt/etc/ndm   /storage/etc/ndm   /etc/ndm   /etc/crontab   /etc/cron*   /opt/etc/cron*   /opt/etc/crontab   /opt/etc/rc.local   ; do
  [ -e "$p" ] && copy_path "$p" || true
done

scan_and_copy_configs() {
  root="$1"
  [ -d "$root" ] || return 0
  cap=$((10 * 1024 * 1024))
  [ "$PROFILE" = "diagnostic" ] && cap=$((2 * 1024 * 1024))
  find "$root" -type f 2>/dev/null | while read -r f; do
    case "$f" in
      *.conf|*.cfg|*.ini|*.json|*.yaml|*.yml|*.toml|*.xml|*.sh|*.rc|*.service|*.rules|*.lua|*.py|*.pl|*.rb|*.js|*.ts|*.env|*.ovpn|*.wg|*.pem|*.crt|*.key|*.pub|*.list|*.txt)
        sz="$(wc -c <"$f" 2>/dev/null || echo 0)"
        if [ "$sz" -le "$cap" ]; then
          copy_path "$f"
        fi
        ;;
    esac
  done
}

scan_and_copy_configs /etc
scan_and_copy_configs /storage/etc
scan_and_copy_configs /opt/etc
scan_and_copy_configs /opt/var

if have opkg; then
  run_cmd "$WORK/entware/opkg_list_installed.txt" opkg list-installed
  run_cmd "$WORK/entware/opkg_status.txt" opkg status
  if [ "$PROFILE" = "forensic" ]; then
    run_sh "$WORK/entware/opkg_files_all.txt" 'opkg list-installed 2>/dev/null | awk "{print \$1}" | while read p; do echo "## $p"; opkg files "$p" 2>/dev/null || true; echo; done'
  fi
fi

run_sh "$WORK/net/ip_addr.txt" 'ip -4 addr 2>/dev/null || ifconfig 2>/dev/null || true'
run_sh "$WORK/net/ip_addr6.txt" 'ip -6 addr 2>/dev/null || true'
run_sh "$WORK/net/ip_route.txt" 'ip route 2>/dev/null || route -n 2>/dev/null || true'
run_sh "$WORK/net/listen_ports.txt" 'ss -lntup 2>/dev/null || netstat -lntup 2>/dev/null || netstat -lntp 2>/dev/null || true'
run_sh "$WORK/net/resolv_conf.txt" 'cat /etc/resolv.conf 2>/dev/null || true'
run_sh "$WORK/net/iptables_save.txt" 'iptables-save 2>/dev/null || true'
run_sh "$WORK/net/nft_list_ruleset.txt" 'nft list ruleset 2>/dev/null || true'

probe_http() {
  out="$1"
  url="$2"
  if have curl; then
    curl -k -sS -D - -o /dev/null --max-time 3 "$url" >>"$out" 2>&1 || true
    echo >>"$out"
  elif have wget; then
    wget --server-response --spider -q -T 3 "$url" >>"$out" 2>&1 || true
    echo >>"$out"
  fi
}
API_OUT="$WORK/net/http_probe.txt"
echo "# http probe $(now_utc)" >"$API_OUT" 2>/dev/null || true
IPS="$(ip -4 addr 2>/dev/null | awk '/inet /{print $2}' | cut -d/ -f1 | sort -u)"
[ -z "$IPS" ] && IPS="127.0.0.1"
for ip in $IPS; do
  for port in 80 443 78 79 8081 90 8088 2000 2222; do
    for path in / /auth /rci/ /ci/self-test.txt /ci/startup-config.txt; do
      echo "## https://$ip:$port$path" >>"$API_OUT"
      probe_http "$API_OUT" "https://$ip:$port$path"
      echo "## http://$ip:$port$path" >>"$API_OUT"
      probe_http "$API_OUT" "http://$ip:$port$path"
    done
  done
done

run_sh "$WORK/sys/ps.txt" 'ps w 2>/dev/null || ps 2>/dev/null || true'
run_sh "$WORK/sys/mounts.txt" 'mount 2>/dev/null || cat /proc/mounts 2>/dev/null || true'
run_sh "$WORK/sys/df.txt" 'df -h 2>/dev/null || df 2>/dev/null || true'
run_sh "$WORK/sys/dmesg.txt" 'dmesg 2>/dev/null || true'
run_sh "$WORK/sys/kernel_cmdline.txt" 'cat /proc/cmdline 2>/dev/null || true'
run_sh "$WORK/sys/device_tree_model.txt" 'cat /proc/device-tree/model 2>/dev/null || true'

if [ "$PROFILE" = "forensic" ]; then
  for f in     /proc/cpuinfo /proc/meminfo /proc/uptime /proc/version /proc/loadavg     /proc/net/dev /proc/net/tcp /proc/net/udp /proc/net/unix /proc/net/route     /proc/modules /proc/partitions /proc/interrupts     ; do
    [ -e "$f" ] || continue
    rel="$(relpath "$f")"
    mkdir -p "$(dirname "$WORK/sys/$rel")" 2>/dev/null || true
    cat "$f" >"$WORK/sys/$rel" 2>/dev/null || true
  done
fi

inv="$WORK/sys/executables_inventory.tsv"
echo "path\tmode\tuid\tgid\tsize\tsha256\tfile" >"$inv" 2>/dev/null || true
for d in /bin /sbin /usr/bin /usr/sbin /opt/bin /opt/sbin; do
  [ -d "$d" ] || continue
  find "$d" -type f -perm -111 2>/dev/null | while read -r f; do
    mode="$(ls -l "$f" 2>/dev/null | awk '{print $1}')"
    uidgid="$(ls -n "$f" 2>/dev/null | awk '{print $3"\t"$4}')"
    size="$(ls -n "$f" 2>/dev/null | awk '{print $5}')"
    sha="NA"
    if have sha256sum; then sha="$(sha256sum "$f" 2>/dev/null | awk '{print $1}')"; fi
    ftype="NA"
    if have file; then ftype="$(file -b "$f" 2>/dev/null | tr '\t' ' ' | head -c 200)"; fi
    printf "%s\t%s\t%s\t%s\t%s\t%s\n" "$f" "$mode" "$uidgid" "$size" "$sha" "$ftype" >>"$inv" 2>/dev/null || true
  done
done

COL_OUT_DIR="$WORK/sys/collectors"
mkdir -p "$COL_OUT_DIR" 2>/dev/null || true

want_collector() {
  name="$1"
  [ "$COLLECTORS" = "all" ] && return 0
  [ "$COLLECTORS" = "auto" ] && return 0
  echo "$COLLECTORS" | tr ',' '\n' | grep -qx "$name"
}

run_collector_py() {
  if install_cmd_if_missing python3 python3 python3-light; then :; fi
  if have python3 && [ -x "$COLLECTORS_DIR/py/analyze.py" ]; then
    python3 "$COLLECTORS_DIR/py/analyze.py" "$WORK" "$MODE" "$PROFILE" >/dev/null 2>&1 || true
    echo "ok" >"$COL_OUT_DIR/python.status" 2>/dev/null || true
  else
    echo "python3 not available" >"$COL_OUT_DIR/python.status" 2>/dev/null || true
  fi
}

run_collector_generic() {
  interp="$1"
  script="$2"
  outfile="$3"

  case "$interp" in
    perl) install_cmd_if_missing perl perl || true ;;
    lua) install_cmd_if_missing lua lua || true ;;
    ruby) install_cmd_if_missing ruby ruby || true ;;
    node) install_cmd_if_missing node node || true ;;
    go) install_cmd_if_missing go go || true ;;
  esac

  if [ "$interp" = "go" ]; then
    if [ -x "$COLLECTORS_DIR/go/run.sh" ]; then
      sh "$COLLECTORS_DIR/go/run.sh" "$outfile" "$WORK/tmp" >/dev/null 2>&1 || true
    else
      echo "go collector missing" >"$outfile"
    fi
    return 0
  fi

  if have "$interp" && [ -x "$script" ]; then
    "$script" "$outfile" >/dev/null 2>&1 || true
  else
    echo "$interp not available" >"$outfile" 2>/dev/null || true
  fi
}

if want_collector python; then run_collector_py; fi
if want_collector perl; then run_collector_generic perl "$COLLECTORS_DIR/perl/inventory.pl" "$COL_OUT_DIR/perl_inventory.txt"; fi
if want_collector lua; then run_collector_generic lua "$COLLECTORS_DIR/lua/inventory.lua" "$COL_OUT_DIR/lua_inventory.txt"; fi
if want_collector ruby; then run_collector_generic ruby "$COLLECTORS_DIR/ruby/inventory.rb" "$COL_OUT_DIR/ruby_inventory.txt"; fi
if want_collector node; then run_collector_generic node "$COLLECTORS_DIR/node/inventory.js" "$COL_OUT_DIR/node_inventory.txt"; fi
if want_collector go; then run_collector_generic go "$COLLECTORS_DIR/go/run.sh" "$COL_OUT_DIR/go_inventory.txt"; fi

if [ ! -f "$WORK/analysis/REPORT_RU.md" ]; then
  echo "# Отчёт keenetic-maxprobe\n\nPython3 недоступен — отчёт урезан." >"$WORK/analysis/REPORT_RU.md" 2>/dev/null || true
  echo "# Sensitive locations\n\nPython3 недоступен — файл не создан." >"$WORK/analysis/SENSITIVE_LOCATIONS.md" 2>/dev/null || true
fi

run_sh "$WORK/analysis/INDEX_ALL_FILES.txt" "cd '$WORK' && find fs -type f -o -type l 2>/dev/null | sort"
run_sh "$WORK/analysis/INDEX_CONFIG_FILES.txt" "cd '$WORK' && find fs -type f 2>/dev/null | egrep '\\.(conf|cfg|ini|json|ya?ml|toml|xml|sh|rc|service|rules|lua|py|pl|rb|js|ts|env|ovpn|wg|pem|crt|key|pub|list|txt)$' | sort"
run_sh "$WORK/analysis/INDEX_HOOK_SCRIPTS.txt" "cd '$WORK' && find fs -path 'fs/*/ndm/*' -type f 2>/dev/null | sort"
run_sh "$WORK/analysis/INDEX_INITD_SCRIPTS.txt" "cd '$WORK' && find fs -path 'fs/opt/etc/init.d/*' -type f 2>/dev/null | sort"
run_sh "$WORK/analysis/INDEX_INTERACTION_FILES.txt" "cd '$WORK' && { find fs -path 'fs/*/ndm/*' -type f; find fs -path 'fs/opt/etc/init.d/*' -type f; find fs -path 'fs/etc/crontab' -type f; find fs -path 'fs/opt/etc/cron*' -type f; find fs -path 'fs/etc/cron*' -type f; } 2>/dev/null | sort -u"

{
  echo "program=$PROG"
  echo "version=$VERSION"
  echo "host=$HOST"
  echo "utc_start=$TS"
  echo "mode=$MODE"
  echo "profile=$PROFILE"
  echo "collectors=$COLLECTORS"
  echo "outdir=$OUTDIR"
  echo "archive=$ARCHIVE"
} >"$WORK/meta/meta.txt" 2>/dev/null || true

( cd "$WORK" && tar -czf "$ARCHIVE" . ) 2>/dev/null || tar -czf "$ARCHIVE" -C "$WORK" . 2>/dev/null || true
if have sha256sum; then sha256sum "$ARCHIVE" >"$ARCHIVE.sha256" 2>/dev/null || true; fi

if have opkg && [ -s "$ADDED_PKGS" ] && [ "$NO_INSTALL" -eq 0 ]; then
  tac "$ADDED_PKGS" 2>/dev/null | while read -r p; do
    [ -n "$p" ] || continue
    opkg remove "$p" >/dev/null 2>&1 || true
  done
fi

log "Created: $ARCHIVE"
trap - EXIT INT TERM
rm -rf "$WORK" 2>/dev/null || true
exit 0
