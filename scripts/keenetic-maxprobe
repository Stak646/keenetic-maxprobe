#!/bin/sh
# keenetic-maxprobe — maximal KeeneticOS + Entware probe
# Version: 0.7.1
#
# Goals:
#  - Collect a "snapshot" archive for debugging / backup (KeeneticOS + OPKG/Entware)
#  - Always generate analysis/REPORT_RU.md and analysis/REPORT_EN.md (minimal fallback)
#  - Detect where OPKG is mounted (USB vs internal storage) and reflect it in meta/ + report
#
# POSIX sh (busybox/ash compatible). No bashisms.

set -u

VERSION="0.7.1"
PROG="keenetic-maxprobe"

# Prefer Entware first
PATH="/opt/bin:/opt/sbin:/opt/usr/bin:/opt/usr/sbin:/usr/sbin:/usr/bin:/sbin:/bin:$PATH"
export PATH
umask 077

# ---------------- defaults (may be overridden by config/CLI) ----------------
LANG_UI="ru"              # ru|en
PROFILE="auto"            # auto|forensic|diagnostic|lite
MODE="full"               # full|safe|extream
COLLECTORS="all"          # all|shonly|shpy|custom
CUSTOM_COLLECTORS=""      # comma list: py,go,lua,node,perl,ruby
OUTDIR=""                 # deprecated (ignored unless /var/tmp)
CLEAN_OLD=0
CLEAN_TMP=0
DEBUG=1
SPINNER=1
YES=0

# deps
NO_INSTALL=0               # do not install anything via opkg
DEPS_MODE="cleanup"        # cleanup|keep
DEPS_LEVEL="core"          # core|collectors

# Web UI (optional)
WEB=0
WEB_BIND="127.0.0.1"
WEB_PORT="8088"

# resource limits (best-effort)
MAX_CPU=85
MAX_MEM=95
JOBS="auto"               # auto|N

CONFIG_PATH="/opt/etc/keenetic-maxprobe.conf"
SHARE_DIR="/opt/share/keenetic-maxprobe"
COLLECTORS_DIR="$SHARE_DIR/collectors"

# allow running from git repo without install
if [ ! -d "$COLLECTORS_DIR" ]; then
  _sd="$(CDPATH= cd -- "$(dirname -- "$0")" 2>/dev/null && pwd 2>/dev/null || echo "")"
  if [ -n "$_sd" ] && [ -d "$_sd/../collectors" ]; then
    COLLECTORS_DIR="$_sd/../collectors"
  fi
fi

# ---------------- runtime globals ----------------
OUTBASE=""
BASE=""
WORK=""
ARCHIVE=""
RUNLOG=""
ERRLOG=""
PHASE_FILE=""
PROGRESS_FILE=""
START_EPOCH=""
TOTAL_STEPS=0
STEP_NO=0
JOBS_N=1

ENTWARE_PREFIX="/opt"          # OPKG mountpoint on Keenetic
OPKG_MOUNT_SRC=""
OPKG_FS_TYPE=""
OPKG_STORAGE_HINT=""           # usb|internal|unknown

# ---------------- i18n ----------------
tr() {
  key="$1"
  case "${LANG_UI:-ru}" in
    en)
      case "$key" in
        STARTING) echo "[+] Starting probe";;
        DONE) echo "[+] Done. Archive:";;
        WARN_SPACE) echo "[!] Low free space in output dir; consider --clean-tmp";;
        WARN_OUTDIR) echo "[!] --outdir is deprecated; output is forced to /var/tmp";;
        *) echo "$key";;
      esac
      ;;
    *)
      case "$key" in
        STARTING) echo "[+] Старт диагностики";;
        DONE) echo "[+] Готово. Архив:";;
        WARN_SPACE) echo "[!] Мало свободного места в папке вывода; попробуйте --clean-tmp";;
        WARN_OUTDIR) echo "[!] --outdir устарел; вывод фиксирован в /var/tmp";;
        *) echo "$key";;
      esac
      ;;
  esac
}

now_utc() { date -u '+%Y-%m-%dT%H:%M:%SZ' 2>/dev/null || date '+%Y-%m-%dT%H:%M:%SZ'; }
ts_utc_path() { date -u '+%Y%m%dT%H%M%SZ' 2>/dev/null || date '+%Y%m%dT%H%M%SZ'; }
have() { command -v "$1" >/dev/null 2>&1; }
ensure_dir() { d="$1"; [ -n "$d" ] || return 1; [ -d "$d" ] && return 0; mkdir -p "$d" 2>/dev/null || return 1; }

say() { ts="$(now_utc)"; printf '%s %s\n' "$ts" "$*" >&2; [ -n "${RUNLOG:-}" ] && printf '%s %s\n' "$ts" "$*" >>"$RUNLOG" 2>/dev/null || true; }
warn(){ ts="$(now_utc)"; printf '%s [!] %s\n' "$ts" "$*" >&2; [ -n "${ERRLOG:-}" ] && printf '%s [!] %s\n' "$ts" "$*" >>"$ERRLOG" 2>/dev/null || true; }
die() { warn "$*"; exit 1; }

sanitize_name() { printf '%s' "$1" | sed 's/[^A-Za-z0-9._-]/_/g'; }

# ---------------- config ----------------
load_config() {
  [ -f "$CONFIG_PATH" ] || return 0
  # shellcheck disable=SC1090
  . "$CONFIG_PATH" 2>/dev/null || true
  LANG_UI="${LANG_UI:-ru}"
  PROFILE="${PROFILE:-auto}"
  MODE="${MODE:-full}"
  COLLECTORS="${COLLECTORS:-all}"
  CUSTOM_COLLECTORS="${CUSTOM_COLLECTORS:-}"
  OUTDIR="${OUTDIR:-}"
  CLEAN_OLD="${CLEAN_OLD:-0}"
  CLEAN_TMP="${CLEAN_TMP:-0}"
  DEBUG="${DEBUG:-1}"
  SPINNER="${SPINNER:-1}"
  YES="${YES:-0}"
  NO_INSTALL="${NO_INSTALL:-0}"
  DEPS_MODE="${DEPS_MODE:-cleanup}"
  DEPS_LEVEL="${DEPS_LEVEL:-core}"
  MAX_CPU="${MAX_CPU:-85}"
  MAX_MEM="${MAX_MEM:-95}"
  JOBS="${JOBS:-auto}"
  WEB="${WEB:-0}"
  WEB_BIND="${WEB_BIND:-127.0.0.1}"
  WEB_PORT="${WEB_PORT:-8088}"
}

save_config() {
  ensure_dir "$(dirname "$CONFIG_PATH")" || true
  {
    echo "# $PROG config"
    echo "LANG_UI=\"$LANG_UI\""
    echo "PROFILE=\"$PROFILE\""
    echo "MODE=\"$MODE\""
    echo "COLLECTORS=\"$COLLECTORS\""
    echo "CUSTOM_COLLECTORS=\"$CUSTOM_COLLECTORS\""
    echo "CLEAN_OLD=$CLEAN_OLD"
    echo "CLEAN_TMP=$CLEAN_TMP"
    echo "DEBUG=$DEBUG"
    echo "SPINNER=$SPINNER"
    echo "NO_INSTALL=$NO_INSTALL"
    echo "DEPS_MODE=\"$DEPS_MODE\""
    echo "DEPS_LEVEL=\"$DEPS_LEVEL\""
    echo "MAX_CPU=$MAX_CPU"
    echo "MAX_MEM=$MAX_MEM"
    echo "JOBS=\"$JOBS\""
    echo "WEB=$WEB"
    echo "WEB_BIND=\"$WEB_BIND\""
    echo "WEB_PORT=\"$WEB_PORT\""
  } >"$CONFIG_PATH" 2>/dev/null || true
}

usage() {
  cat >&2 <<'USAGE'
keenetic-maxprobe [options]

Core:
  --init
  --lang {ru|en}
  --mode {full|safe|extream}
  --profile {auto|forensic|diagnostic|lite}
  --collectors {all|shonly|shpy|custom}
  --custom-collectors LIST   comma list: py,go,lua,node,perl,ruby

Output:
  --outdir DIR      deprecated (ignored unless DIR==/var/tmp)
  --clean-old
  --clean-tmp

Deps:
  --no-install
  --deps-mode {cleanup|keep}
  --deps-level {core|collectors}

Web UI:
  --web
  --web-bind IP
  --web-port PORT

UX:
  -y, --yes
USAGE
}

ask() {
  prompt="$1"; def="$2"
  [ "${YES:-0}" -eq 1 ] && { printf '%s' "$def"; return 0; }
  printf '%s (default %s): ' "$prompt" "$def" >&2
  IFS= read -r ans || ans=""
  [ -n "$ans" ] || ans="$def"
  printf '%s' "$ans"
}

ask_yn() {
  prompt="$1"; def="$2"
  [ "${YES:-0}" -eq 1 ] && { [ "$def" = "y" ] && return 0 || return 1; }
  while :; do
    ans="$(ask "$prompt [y/n]" "$def")"
    case "$ans" in y|Y|yes) return 0;; n|N|no) return 1;; esac
  done
}

init_wizard() {
  echo >&2
  echo "== keenetic-maxprobe init wizard ==" >&2
  echo >&2
  LANG_UI="$(ask "UI language ru/en" "$LANG_UI")"; case "$LANG_UI" in ru|en) :;; *) LANG_UI="ru";; esac
  PROFILE="$(ask "Profile auto/forensic/diagnostic/lite" "$PROFILE")"; case "$PROFILE" in auto|forensic|diagnostic|lite) :;; *) PROFILE="auto";; esac
  MODE="$(ask "Mode full/safe/extream" "$MODE")"; case "$MODE" in full|safe|extream) :;; *) MODE="full";; esac
  COLLECTORS="$(ask "Collectors all/shonly/shpy/custom" "$COLLECTORS")"; case "$COLLECTORS" in all|shonly|shpy|custom) :;; *) COLLECTORS="all";; esac
  [ "$COLLECTORS" = "custom" ] && CUSTOM_COLLECTORS="$(ask "Custom collectors list" "$CUSTOM_COLLECTORS")"
  if ask_yn "Clean old archives in /var/tmp?" "n"; then CLEAN_OLD=1; else CLEAN_OLD=0; fi
  if ask_yn "Clean /tmp before run?" "n"; then CLEAN_TMP=1; else CLEAN_TMP=0; fi
  if ask_yn "Enable debug?" "y"; then DEBUG=1; else DEBUG=0; fi
  if ask_yn "Cleanup temporary opkg installs after run?" "y"; then DEPS_MODE="cleanup"; else DEPS_MODE="keep"; fi
  if ask_yn "Show spinner/progress?" "y"; then SPINNER=1; else SPINNER=0; fi
  JOBS="$(ask "Parallel jobs (auto/1/2/3..)" "$JOBS")"
  MAX_CPU="$(ask "Max CPU %" "$MAX_CPU")"
  MAX_MEM="$(ask "Max RAM %" "$MAX_MEM")"
  save_config
  echo >&2
  echo "[+] Saved: $CONFIG_PATH" >&2
}

parse_args() {
  INIT=0
  while [ $# -gt 0 ]; do
    case "$1" in
      --init) INIT=1;;
      --lang) LANG_UI="${2:-ru}"; shift;;
      --mode) MODE="${2:-full}"; shift;;
      --extream|--extreme) MODE="extream";;
      --profile) PROFILE="${2:-auto}"; shift;;
      --collectors) COLLECTORS="${2:-all}"; shift;;
      --custom-collectors) CUSTOM_COLLECTORS="${2:-}"; COLLECTORS="custom"; shift;;
      --outdir) OUTDIR="${2:-}"; shift;;
      --clean-old) CLEAN_OLD=1;;
      --clean-tmp) CLEAN_TMP=1;;
      --debug) DEBUG=1;;
      --no-debug) DEBUG=0;;
      --spinner) SPINNER=1;;
      --no-spinner) SPINNER=0;;
      -y|--yes) YES=1;;
      --no-install) NO_INSTALL=1;;
      --deps-mode) DEPS_MODE="${2:-cleanup}"; shift;;
      --deps-level) DEPS_LEVEL="${2:-core}"; shift;;
      --max-cpu) MAX_CPU="${2:-85}"; shift;;
      --max-mem) MAX_MEM="${2:-95}"; shift;;
      --jobs) JOBS="${2:-auto}"; shift;;
      --web) WEB=1;;
      --web-bind) WEB_BIND="${2:-127.0.0.1}"; shift;;
      --web-port) WEB_PORT="${2:-8088}"; shift;;
      -h|--help) usage; exit 0;;
      *) warn "Unknown arg: $1"; usage; exit 2;;
    esac
    shift
  done
}

# ---------------- progress/spinner ----------------
set_phase() { [ -n "${PHASE_FILE:-}" ] && printf '%s\n' "$*" >"$PHASE_FILE" 2>/dev/null || true; }
set_progress() { [ -n "${PROGRESS_FILE:-}" ] && printf '%s/%s\n' "$STEP_NO" "$TOTAL_STEPS" >"$PROGRESS_FILE" 2>/dev/null || true; }

spinner_loop() {
  i=0
  chars='-\\|/'
  while :; do
    i=$((i + 1))
    idx=$((i % 4))
    c="$(printf '%s' "$chars" | cut -c $((idx + 1)) )"
    phase="$(cat "$PHASE_FILE" 2>/dev/null || echo "...")"
    prog="$(cat "$PROGRESS_FILE" 2>/dev/null || echo "0/0")"
    now="$(date +%s 2>/dev/null || echo 0)"
    if [ -n "${START_EPOCH:-}" ] && [ "$START_EPOCH" -gt 0 ] 2>/dev/null && [ "$now" -gt 0 ] 2>/dev/null; then
      el=$((now - START_EPOCH))
    else
      el=0
    fi
    printf '\r[%s] %s | %s | %ss' "$c" "$prog" "$phase" "$el" >&2
    sleep 1
  done
}

start_spinner() {
  [ "${SPINNER:-1}" -eq 1 ] || return 0
  spinner_loop &
  SPINNER_PID=$!
}

stop_spinner() {
  [ -n "${SPINNER_PID:-}" ] || return 0
  kill "$SPINNER_PID" 2>/dev/null || true
  wait "$SPINNER_PID" 2>/dev/null || true
  printf '\r%s\r' " " >&2
}

# ---------------- output/workdir policy ----------------
# Project policy: store output in /var/tmp and exclude /var/tmp from mirroring.
pick_outdir() {
  if ensure_dir "/var/tmp" && [ -w "/var/tmp" ]; then
    echo "/var/tmp"; return 0
  fi
  if ensure_dir "/tmp" && [ -w "/tmp" ]; then
    echo "/tmp"; return 0
  fi
  echo "."
}

clean_tmp_dir() {
  [ "${CLEAN_TMP:-0}" -eq 1 ] || return 0
  set_phase "Cleaning /tmp (best-effort)"
  rm -rf /tmp/keenetic-maxprobe-* 2>/dev/null || true
}

clean_old_outputs() {
  [ "${CLEAN_OLD:-0}" -eq 1 ] || return 0
  set_phase "Cleaning old archives"
  rm -f "$OUTBASE"/keenetic-maxprobe-*.tar.gz "$OUTBASE"/keenetic-maxprobe-*.sha256 2>/dev/null || true
}

check_free_space_warn() {
  have df || return 0
  free_kb="$(df -k "$OUTBASE" 2>/dev/null | awk 'NR==2{print $4}' || echo 0)"
  [ -n "$free_kb" ] || free_kb=0
  if [ "$free_kb" -gt 0 ] 2>/dev/null && [ "$free_kb" -lt 8192 ] 2>/dev/null; then
    warn "$(tr WARN_SPACE) (free_kb=$free_kb)"
  fi
}

# ---------------- OPKG/Entware mount detection ----------------
# On Keenetic, OPKG always uses /opt as mountpoint; the storage behind /opt may be USB or internal (/storage, UBIFS).
detect_opkg_mount() {
  OPKG_MOUNT_SRC=""
  OPKG_FS_TYPE=""
  OPKG_STORAGE_HINT="unknown"

  if have mount; then
    # mount output usually: SRC on /opt type FSTYPE (...)
    line="$(mount 2>/dev/null | awk '$3=="/opt" {print; exit}' 2>/dev/null)"
    if [ -n "$line" ]; then
      OPKG_MOUNT_SRC="$(printf '%s' "$line" | awk '{print $1}' 2>/dev/null)"
      OPKG_FS_TYPE="$(printf '%s' "$line" | awk '{for(i=1;i<=NF;i++) if($i=="type") {print $(i+1); exit}}' 2>/dev/null)"
    fi
  fi

  # Heuristic: internal storage often involves /storage, UBIFS, ubi*; USB tends to /dev/sd*.
  case "${OPKG_MOUNT_SRC:-}" in
    /storage*|storage:*|ubi*|/dev/ubi*|mtd*|/dev/mtd*|overlay*) OPKG_STORAGE_HINT="internal";;
    /dev/sd*|/dev/mmc*|/dev/nvme*) OPKG_STORAGE_HINT="usb";;
    "") OPKG_STORAGE_HINT="unknown";;
    *) OPKG_STORAGE_HINT="unknown";;
  esac
}

write_opkg_mount_meta() {
  ensure_dir "$WORK/meta" || return 0
  printf '%s\n' "$ENTWARE_PREFIX" >"$WORK/meta/entware_prefix.txt" 2>/dev/null || true
  printf '%s\n' "${OPKG_MOUNT_SRC:-}" >"$WORK/meta/opkg_mount_source.txt" 2>/dev/null || true
  printf '%s\n' "${OPKG_FS_TYPE:-}" >"$WORK/meta/opkg_fs_type.txt" 2>/dev/null || true
  printf '%s\n' "${OPKG_STORAGE_HINT:-}" >"$WORK/meta/opkg_storage_hint.txt" 2>/dev/null || true
  have df && df -P "$ENTWARE_PREFIX" 2>/dev/null >"$WORK/meta/df_opt.txt" || true
  have mount && mount 2>/dev/null | awk '$3=="/opt" {print}' >"$WORK/meta/mount_opt.txt" 2>/dev/null || true
}

# ---------------- deps via opkg (best-effort) ----------------
opkg_snapshot() {
  out="$1"
  if have opkg; then
    opkg list-installed 2>/dev/null | awk '{print $1}' | sort -u >"$out" 2>/dev/null || true
  else
    : >"$out" 2>/dev/null || true
  fi
}

ensure_pkg() {
  pkg="$1"
  [ "${NO_INSTALL:-0}" -eq 1 ] && return 1
  have opkg || return 1
  opkg install "$pkg" >/dev/null 2>&1 || return 1
  return 0
}

ensure_cmd_via_opkg() {
  cmd="$1"; shift
  have "$cmd" && return 0
  [ "${NO_INSTALL:-0}" -eq 1 ] && return 1
  have opkg || return 1
  for pkg in "$@"; do
    say "[*] Installing (opkg) $pkg for missing cmd: $cmd"
    opkg install "$pkg" >/dev/null 2>&1 || true
    have "$cmd" && return 0
  done
  return 1
}

cleanup_temp_packages() {
  [ "${DEPS_MODE:-cleanup}" = "cleanup" ] || return 0
  [ "${NO_INSTALL:-0}" -eq 1 ] && return 0
  have opkg || return 0

  before="$WORK/tmp/opkg_before.txt"
  after="$WORK/tmp/opkg_after.txt"
  diff="$WORK/tmp/opkg_installed_by_kmp.txt"

  opkg_snapshot "$after"
  if [ -s "$before" ] && [ -s "$after" ]; then
    grep -F -x -v -f "$before" "$after" >"$diff" 2>/dev/null || true
  else
    : >"$diff" 2>/dev/null || true
  fi

  [ -s "$diff" ] || return 0
  set_phase "Cleanup: temp opkg packages"

  while IFS= read -r pkg; do
    [ -n "$pkg" ] || continue
    say "[*] opkg remove $pkg"
    opkg remove "$pkg" >/dev/null 2>&1 || warn "opkg remove failed: $pkg"
  done <"$diff"
}

maybe_install_collector_runtimes() {
  [ "${DEPS_LEVEL:-core}" = "collectors" ] || return 0
  [ "${NO_INSTALL:-0}" -eq 1 ] && return 0
  have opkg || return 0

  # Try to install interpreters if missing and corresponding collectors are enabled.
  if collector_enabled py && ! have python3; then ensure_pkg python3 || true; fi
  if collector_enabled lua && ! have lua; then ensure_pkg lua || true; fi
  if collector_enabled node && ! have node; then ensure_pkg node || true; fi
  if collector_enabled perl && ! have perl; then ensure_pkg perl || true; fi
  if collector_enabled ruby && ! have ruby; then ensure_pkg ruby || true; fi
}

# ---------------- collectors selection ----------------
collector_enabled() {
  name="$1"  # py go lua node perl ruby
  case "$COLLECTORS" in
    all) return 0;;
    shonly) return 1;;
    shpy) [ "$name" = "py" ] && return 0 || return 1;;
    custom)
      printf ',%s,' "$CUSTOM_COLLECTORS" | grep -q ",${name}," 2>/dev/null
      return $?;;
    *) return 0;;
  esac
}

# ---------------- step runner ----------------
step() {
  title="$1"; func="$2"
  STEP_NO=$((STEP_NO + 1))
  set_progress
  set_phase "$title"
  say "[*] $title"
  $func || warn "Step failed: $title"
}

# ---------------- copy/mirror helpers ----------------
copy_path() {
  src="$1"; dst="$2"
  ensure_dir "$(dirname "$dst")" || return 1
  cp -a "$src" "$dst" 2>/dev/null || cp "$src" "$dst" 2>/dev/null || return 1
  return 0
}

mirror_dir() {
  src="$1"; dst="$2"; label="$3"
  [ -d "$src" ] || return 0
  # Never mirror output base to avoid recursion.
  case "$src" in
    /var/tmp|/var/tmp/*) warn "Skip mirror of $src (output base is excluded by policy)"; return 0;;
  esac
  ensure_dir "$dst" || return 0
  say "[*] Mirror: $label ($src -> $dst)"
  if have ionice; then
    (cd "$src" 2>/dev/null && ionice -c3 nice -n 19 tar -cf - . 2>/dev/null) | (cd "$dst" 2>/dev/null && ionice -c3 nice -n 19 tar -xpf - 2>/dev/null) || true
  elif have nice; then
    (cd "$src" 2>/dev/null && nice -n 19 tar -cf - . 2>/dev/null) | (cd "$dst" 2>/dev/null && nice -n 19 tar -xpf - 2>/dev/null) || true
  else
    (cd "$src" 2>/dev/null && tar -cf - . 2>/dev/null) | (cd "$dst" 2>/dev/null && tar -xpf - 2>/dev/null) || true
  fi
}

# ---------------- collection functions ----------------
collect_meta() {
  ensure_dir "$WORK/meta" || true
  printf '%s\n' "$VERSION" >"$WORK/meta/tool_version.txt" 2>/dev/null || true
  printf '%s\n' "$(now_utc)" >"$WORK/meta/started_utc.txt" 2>/dev/null || true
  (uname -a 2>/dev/null || true) >"$WORK/meta/uname.txt" 2>/dev/null || true
  (hostname 2>/dev/null || cat /proc/sys/kernel/hostname 2>/dev/null || echo keenetic) >"$WORK/meta/hostname.txt" 2>/dev/null || true

  # basic profile selection
  cores="$(grep -c '^processor' /proc/cpuinfo 2>/dev/null || echo 1)"; [ "$cores" -gt 0 ] 2>/dev/null || cores=1
  mem_kb="$(awk '/MemTotal:/ {print $2}' /proc/meminfo 2>/dev/null || echo 0)"
  out_free_kb="0"; have df && out_free_kb="$(df -k "$OUTBASE" 2>/dev/null | awk 'NR==2{print $4}' || echo 0)"

  prof="$PROFILE"
  if [ "$PROFILE" = "auto" ]; then
    if [ "$mem_kb" -ge 524288 ] 2>/dev/null && [ "$cores" -ge 2 ] 2>/dev/null; then
      prof="forensic"
    elif [ "$mem_kb" -ge 262144 ] 2>/dev/null; then
      prof="diagnostic"
    else
      prof="lite"
    fi
  fi
  PROFILE="$prof"

  if [ "$JOBS" = "auto" ]; then
    if [ "$PROFILE" = "lite" ]; then JOBS_N=1
    else
      if [ "$cores" -ge 2 ] 2>/dev/null; then JOBS_N=2; else JOBS_N=1; fi
      if [ "$MODE" = "extream" ] && [ "$cores" -ge 4 ] 2>/dev/null; then JOBS_N=3; fi
    fi
  else
    JOBS_N="$JOBS"
  fi

  # extream implies deeper deps by default
  if [ "$MODE" = "extream" ] && [ "$DEPS_LEVEL" != "collectors" ]; then
    DEPS_LEVEL="collectors"
  fi

  # JSON (manual minimal)
  cat >"$WORK/meta/profile_selected.json" <<EOFJ
{
  "tool": "${PROG}",
  "version": "${VERSION}",
  "lang": "${LANG_UI}",
  "profile": "${PROFILE}",
  "mode": "${MODE}",
  "collectors": "${COLLECTORS}",
  "custom_collectors": "${CUSTOM_COLLECTORS}",
  "deps_mode": "${DEPS_MODE}",
  "deps_level": "${DEPS_LEVEL}",
  "max_cpu": ${MAX_CPU},
  "max_mem": ${MAX_MEM},
  "jobs": "${JOBS}",
  "jobs_n": ${JOBS_N},
  "cores": ${cores},
  "mem_kb": ${mem_kb},
  "out_free_kb": ${out_free_kb}
}
EOFJ

  if [ "$DEBUG" -eq 1 ]; then
    env | sort >"$WORK/meta/env.txt" 2>/dev/null || true
    ulimit -a >"$WORK/meta/ulimit.txt" 2>/dev/null || true
  fi

  detect_opkg_mount
  write_opkg_mount_meta
}

collect_proc() {
  ensure_dir "$WORK/sys/proc" || true
  for f in cpuinfo meminfo loadavg uptime version cmdline partitions mounts; do
    [ -f "/proc/$f" ] && copy_path "/proc/$f" "$WORK/sys/proc/$f" || true
  done
  if [ -d /proc/net ]; then
    ensure_dir "$WORK/sys/proc/net" || true
    for f in dev arp route tcp udp tcp6 udp6 igmp igmp6 if_inet6; do
      [ -f "/proc/net/$f" ] && copy_path "/proc/net/$f" "$WORK/sys/proc/net/$f" || true
    done
  fi
}

collect_sys_commands() {
  ensure_dir "$WORK/sys" || true
  (df -h 2>/dev/null || true) >"$WORK/sys/df.txt" 2>/dev/null || true
  (mount 2>/dev/null || true) >"$WORK/sys/mount.txt" 2>/dev/null || true
  (ps w 2>/dev/null || ps 2>/dev/null || true) >"$WORK/sys/ps.txt" 2>/dev/null || true
  have top && (top -b -n 1 2>/dev/null || true) >"$WORK/sys/top.txt" 2>/dev/null || true
  have dmesg && (dmesg 2>/dev/null || true) >"$WORK/sys/dmesg.txt" 2>/dev/null || true
}

mirror_filesystems() {
  ensure_dir "$WORK/fs" || true
  mirror_dir "/etc" "$WORK/fs/etc" "/etc"
  [ -d /storage/etc ] && mirror_dir "/storage/etc" "$WORK/fs/storage/etc" "/storage/etc" || true
  [ -d /storage/system ] && mirror_dir "/storage/system" "$WORK/fs/storage/system" "/storage/system" || true

  # OPKG/Entware (always /opt mountpoint)
  [ -d "$ENTWARE_PREFIX/etc" ] && mirror_dir "$ENTWARE_PREFIX/etc" "$WORK/fs/opt/etc" "$ENTWARE_PREFIX/etc" || true
  [ -d "$ENTWARE_PREFIX/var/lib/opkg" ] && mirror_dir "$ENTWARE_PREFIX/var/lib/opkg" "$WORK/fs/opt/var/lib/opkg" "$ENTWARE_PREFIX/var/lib/opkg" || true
  [ -d "$ENTWARE_PREFIX/var/log" ] && mirror_dir "$ENTWARE_PREFIX/var/log" "$WORK/fs/opt/var/log" "$ENTWARE_PREFIX/var/log" || true

  if [ "$PROFILE" = "forensic" ] || [ "$MODE" = "extream" ]; then
    [ -d /storage ] && mirror_dir "/storage" "$WORK/fs/storage" "/storage (deep)" || true
  fi
  if [ "$MODE" = "extream" ]; then
    [ -d "$ENTWARE_PREFIX" ] && mirror_dir "$ENTWARE_PREFIX" "$WORK/fs/opt" "/opt (deep)" || true
    [ -d /root ] && mirror_dir "/root" "$WORK/fs/root" "/root (deep)" || true
  fi

  # SAFE redactions (best-effort)
  if [ "$MODE" = "safe" ]; then
    set_phase "SAFE: redacting high-risk files (best-effort)"
    rm -f "$WORK/fs/etc/shadow" "$WORK/fs/etc/gshadow" 2>/dev/null || true
    rm -f "$WORK/fs/opt/etc/shadow" "$WORK/fs/opt/etc/gshadow" 2>/dev/null || true
  fi
}

collect_entware() {
  ensure_dir "$WORK/entware" || true
  ensure_dir "$WORK/entware/opkg" || true
  ensure_dir "$WORK/entware/init.d" || true

  if have opkg; then
    opkg --version 2>/dev/null >"$WORK/entware/opkg/version.txt" || true
    opkg print-architecture 2>/dev/null >"$WORK/entware/opkg/arch.txt" || true
    # keep docs layout
    opkg list-installed 2>/dev/null >"$WORK/entware/opkg/list_installed.txt" || true
    opkg status 2>/dev/null | head -n 4000 >"$WORK/entware/opkg/status_head.txt" || true
    # analyzer compatibility
    opkg list-installed 2>/dev/null >"$WORK/entware/opkg_list_installed.txt" || true
  else
    printf '%s\n' "opkg not found; OPKG/Entware may be disabled" >"$WORK/entware/opkg/status.txt" 2>/dev/null || true
  fi

  # capture OPKG component hooks and init scripts
  if [ -d "$ENTWARE_PREFIX/etc/init.d" ]; then
    ls -la "$ENTWARE_PREFIX/etc/init.d" 2>/dev/null >"$WORK/entware/init.d/list.txt" || true
    gen_services_json "$ENTWARE_PREFIX/etc/init.d" "$WORK/entware/services.json" || true
  fi

  for f in "$ENTWARE_PREFIX/etc/opkg.conf" "$ENTWARE_PREFIX/etc/opkg"/*conf /etc/opkg.conf; do
    [ -f "$f" ] || continue
    bn="$(basename "$f")"
    cp -f "$f" "$WORK/entware/opkg/$bn" 2>/dev/null || true
  done
}

gen_services_json() {
  initd="$1"; out="$2"
  ensure_dir "$(dirname "$out")" || return 0
  first=1
  printf '[\n' >"$out" 2>/dev/null || return 0
  for p in "$initd"/*; do
    [ -f "$p" ] || continue
    name="$(basename "$p")"
    exec=0; [ -x "$p" ] && exec=1
    size="$(wc -c <"$p" 2>/dev/null || echo 0)"
    sha=""; have sha256sum && sha="$(sha256sum "$p" 2>/dev/null | awk '{print $1}' | head -n1)"
    jname="$(printf '%s' "$name" | sed 's/\\/\\\\/g; s/"/\\"/g')"
    jpath="$(printf '%s' "$p" | sed 's/\\/\\\\/g; s/"/\\"/g')"
    [ "$first" -eq 1 ] && first=0 || printf ',\n' >>"$out"
    printf ' {"script":"%s","path":"%s","executable":%s,"size":%s,"sha256":"%s"}' \
      "$jname" "$jpath" "$exec" "$size" "$sha" >>"$out" 2>/dev/null || true
  done
  printf '\n]\n' >>"$out" 2>/dev/null || true
}

collect_network() {
  ensure_dir "$WORK/net" || true
  ensure_cmd_via_opkg ip ip-full iproute2 || true
  if have ip; then
    ip addr 2>/dev/null >"$WORK/net/ip_addr.txt" || true
    ip route 2>/dev/null >"$WORK/net/ip_route.txt" || true
    ip rule 2>/dev/null >"$WORK/net/ip_rule.txt" || true
    ip neigh 2>/dev/null >"$WORK/net/ip_neigh.txt" || true
    ip link 2>/dev/null >"$WORK/net/ip_link.txt" || true
  fi
  if have ss; then
    ss -lntup 2>/dev/null >"$WORK/net/ss_listen.txt" || ss -lntu 2>/dev/null >"$WORK/net/ss_listen.txt" || true
  elif have netstat; then
    netstat -lntup 2>/dev/null >"$WORK/net/netstat_listen.txt" || netstat -lntu 2>/dev/null >"$WORK/net/netstat_listen.txt" || true
  fi
  collect_listen_ports || true
}

collect_listen_ports() {
  out="$WORK/net/listen_ports.tsv"
  : >"$out" 2>/dev/null || true
  printf '# proto\tip\tport\tstate\tsource\n' >>"$out" 2>/dev/null || true

  if [ -s "$WORK/net/ss_listen.txt" ]; then
    awk 'BEGIN{OFS="\t"} $1 ~ /LISTEN/ {la=$4; gsub("\\[","",la); gsub("\\]","",la); split(la,a,":"); ip=a[1]; port=a[length(a)]; if(port ~ /^[0-9]+$/) print "tcp", ip, port, $1, "ss" }' \
      "$WORK/net/ss_listen.txt" 2>/dev/null >>"$out" || true
  elif [ -s "$WORK/net/netstat_listen.txt" ]; then
    awk 'BEGIN{OFS="\t"} $1 ~ /tcp/ && $4 ~ /:[0-9]+$/ {split($4,a,":"); ip=a[1]; port=a[length(a)]; print "tcp", ip, port, $6, "netstat" }' \
      "$WORK/net/netstat_listen.txt" 2>/dev/null >>"$out" || true
  fi
}

http_code() {
  scheme="$1"; host="$2"; port="$3"; path="$4"
  have curl || return 1
  curl -k -sS --max-time 2 --connect-timeout 1 -o /dev/null -w '%{http_code}' "$scheme://$host:$port$path" 2>/dev/null || return 1
}

collect_http_probe() {
  ensure_dir "$WORK/net" || true
  out="$WORK/net/http_probe.tsv"
  : >"$out" 2>/dev/null || true
  printf '# ts\thost\tport\tscheme\tpath\tcode\tnote\n' >>"$out" 2>/dev/null || true

  have curl || { ensure_cmd_via_opkg curl curl ca-bundle || true; }

  host="127.0.0.1"
  ports="$(awk 'NF>=3 && $1!="#" {print $3}' "$WORK/net/listen_ports.tsv" 2>/dev/null | sort -n | uniq 2>/dev/null)"
  [ -n "$ports" ] || ports="80 443 8080 8088"

  for port in $ports; do
    for scheme in http https; do
      for path in / /rci/show/system /rci/show/version /rci/; do
        code="000"; note=""
        if have curl; then
          c="$(http_code "$scheme" "$host" "$port" "$path" 2>/dev/null || echo 000)"
          code="$c"
        else
          note="no-curl"
        fi
        printf '%s\t%s\t%s\t%s\t%s\t%s\t%s\n' "$(now_utc)" "$host" "$port" "$scheme" "$path" "$code" "$note" >>"$out" 2>/dev/null || true
      done
    done
  done
}

sanitize_path() {
  p="$1"
  p="${p#/}"
  printf '%s' "$p" | sed 's/[^A-Za-z0-9._-]/_/g'
}

collect_web_probe() {
  have curl || return 0
  ensure_dir "$WORK/web" || true

  hits="$WORK/net/http_probe.tsv"
  [ -s "$hits" ] || return 0

  out="$WORK/web/web_probe.tsv"
  : >"$out" 2>/dev/null || true
  printf '# ts\thost\tport\tscheme\tpath\tcode\tbytes\n' >>"$out" 2>/dev/null || true

  awk 'NF>=7 && $1!="#" {print $2"\t"$3"\t"$4"\t"$5"\t"$6}' "$hits" 2>/dev/null | while IFS="\t" read -r host port scheme path code; do
    case "$code" in
      200|30*|401|403)
        dir="$WORK/web/${host}_${port}_${scheme}"
        ensure_dir "$dir" || continue
        sp="$(sanitize_path "$path")"; [ -n "$sp" ] || sp="root"
        curl -k -sS --max-time 3 --connect-timeout 1 -D "$dir/${sp}.headers" -o "$dir/${sp}.body" "$scheme://$host:$port$path" 2>/dev/null || true
        bytes="0"; [ -f "$dir/${sp}.body" ] && bytes="$(wc -c <"$dir/${sp}.body" 2>/dev/null || echo 0)"
        printf '%s\t%s\t%s\t%s\t%s\t%s\t%s\n' "$(now_utc)" "$host" "$port" "$scheme" "$path" "$code" "$bytes" >>"$out" 2>/dev/null || true
        ;;
      *) :;;
    esac
  done
}

collect_firewall() {
  ensure_dir "$WORK/net" || true
  if have iptables; then
    iptables-save 2>/dev/null >"$WORK/net/iptables_save.txt" || true
  fi
  if have nft; then
    nft list ruleset 2>/dev/null >"$WORK/net/nft_ruleset.txt" || true
  fi
}

collect_ndmc() {
  ensure_dir "$WORK/ndm" || true
  if have ndmc; then
    ndmc -c 'show version' 2>/dev/null >"$WORK/ndm/ndmc_show_version.txt" || true
    ndmc -c 'show system' 2>/dev/null >"$WORK/ndm/ndmc_show_system.txt" || true
    ndmc -c 'show interface' 2>/dev/null >"$WORK/ndm/ndmc_show_interface.txt" || true
    if [ "$PROFILE" = "forensic" ] || [ "$MODE" = "extream" ]; then
      ndmc -c 'show running-config' 2>/dev/null >"$WORK/ndm/ndmc_show_running_config.txt" || true
    fi
  fi
}

scan_sensitive() {
  out="$WORK/analysis/SENSITIVE_LOCATIONS.md"
  ensure_dir "$WORK/analysis" || true
  {
    echo "# Sensitive locations (best-effort)"
    echo
    echo "## System"
    echo "- /etc/passwd /etc/shadow /etc/group"
    echo "- /etc/ppp/*"
    echo "- /etc/wireguard/*"
    echo
    echo "## OPKG /opt"
    echo "- /opt/etc/*"
    echo "- /opt/etc/ssl/*"
    echo "- /opt/etc/openvpn/*"
    echo "- /opt/etc/xray/*"
    echo
    echo "SAFE mode is best-effort and not a guarantee."
  } >"$out" 2>/dev/null || true
}

write_redaction_guides() {
  ensure_dir "$WORK/analysis" || true
  cat >"$WORK/analysis/REDACTION_GUIDE_RU.md" <<'EOF_RU'
# Redaction guide (RU)

Если вы собираетесь отправлять архив третьим лицам:

- Проверьте `analysis/SENSITIVE_LOCATIONS.md`.
- В режиме SAFE некоторые файлы удаляются из `fs/`, но это *best-effort*.
- Для строгой очистки удаляйте из архива файлы с паролями/ключами:
  - `fs/etc/shadow`, `fs/etc/gshadow`
  - `fs/opt/etc/*` (особенно VPN/прокси)
  - `fs/storage/etc/ndm/*` (если содержит секреты)
EOF_RU

  cat >"$WORK/analysis/REDACTION_GUIDE_EN.md" <<'EOF_EN'
# Redaction guide (EN)

If you plan to share the archive:

- Check `analysis/SENSITIVE_LOCATIONS.md`.
- SAFE mode removes some files from `fs/`, but it's best-effort.
- For stricter redaction, remove secrets from the archive (passwords/keys):
  - `fs/etc/shadow`, `fs/etc/gshadow`
  - `fs/opt/etc/*` (VPN/proxy configs)
  - `fs/storage/etc/ndm/*` (if it contains secrets)
EOF_EN
}

generate_reports() {
  ensure_dir "$WORK/analysis" || true

  # Run Python analyzer if available
  if have python3 && [ -f "$COLLECTORS_DIR/py/analyze.py" ]; then
    set_phase "Analysis: python report"
    python3 "$COLLECTORS_DIR/py/analyze.py" --report --workdir "$WORK" \
      >>"$WORK/analysis/python_report_stdout.txt" 2>>"$WORK/analysis/python_report_stderr.txt" || true
  fi

  # Minimal fallback reports (always!)
  if [ ! -s "$WORK/analysis/REPORT_RU.md" ]; then
    cat >"$WORK/analysis/REPORT_RU.md" <<EOF
# Отчёт keenetic-maxprobe (минимальный)

Если вы видите этот минимальный отчёт — Python‑анализатор не смог сформировать полный отчёт.

## OPKG /opt (где хранится)

- Точка монтирования: ${ENTWARE_PREFIX}
- Источник монтирования: ${OPKG_MOUNT_SRC}
- Тип ФС: ${OPKG_FS_TYPE}
- Подсказка (usb/internal): ${OPKG_STORAGE_HINT}

См. также: `meta/df_opt.txt`, `meta/mount_opt.txt`.

## Что смотреть вручную

- `meta/run.log`, `meta/errors.log`
- `fs/` (зеркало конфигов)
- `ndm/` (ndmc snapshots)
- `net/` (сеть + probe)
- `web/` (если включено)
EOF
  fi

  if [ ! -s "$WORK/analysis/REPORT_EN.md" ]; then
    cat >"$WORK/analysis/REPORT_EN.md" <<EOF
# keenetic-maxprobe report (minimal)

If you see this minimal report, the Python analyzer failed or is unavailable.

## OPKG /opt (storage)

- Mountpoint: ${ENTWARE_PREFIX}
- Mount source: ${OPKG_MOUNT_SRC}
- FS type: ${OPKG_FS_TYPE}
- Hint (usb/internal): ${OPKG_STORAGE_HINT}

See also: `meta/df_opt.txt`, `meta/mount_opt.txt`.

## Manual checklist

- `meta/run.log`, `meta/errors.log`
- `fs/` (configs mirror)
- `ndm/` (ndmc snapshots)
- `net/` (network + probe)
- `web/` (if enabled)
EOF
  fi
}

pack_archive() {
  set_phase "Packing archive"
  have tar || { warn "tar not found"; return 1; }
  have gzip || { warn "gzip not found"; return 1; }

  gzip_cmd="gzip -1"
  have nice && gzip_cmd="nice -n 19 gzip -1"

  (cd "$WORK" 2>/dev/null && tar -cf - . 2>/dev/null | sh -c "$gzip_cmd" >"$ARCHIVE") || return 1

  # sha256
  if have sha256sum; then
    sha256sum "$ARCHIVE" 2>/dev/null | awk '{print $1"  "FILENAME}' FILENAME="$(basename "$ARCHIVE")" >"$ARCHIVE.sha256" 2>/dev/null || true
  elif have openssl; then
    openssl dgst -sha256 "$ARCHIVE" 2>/dev/null | awk '{print $NF"  "FILENAME}' FILENAME="$(basename "$ARCHIVE")" >"$ARCHIVE.sha256" 2>/dev/null || true
  fi

  return 0
}

cleanup_workdir() {
  rm -rf "$WORK" 2>/dev/null || true
}

run_collectors_parallel() {
  maybe_install_collector_runtimes || true

  if collector_enabled py && have python3 && [ -f "$COLLECTORS_DIR/py/probe.py" ]; then
    set_phase "Collectors: python probe"
    python3 "$COLLECTORS_DIR/py/probe.py" --workdir "$WORK" \
      >>"$WORK/tmp/python_probe_stdout.txt" 2>>"$WORK/tmp/python_probe_stderr.txt" || true
  fi
}

webui_start() {
  if ! have python3; then
    warn "Web UI requires python3."; return 1
  fi
  srv="$COLLECTORS_DIR/py/webui/server.py"
  if [ ! -f "$srv" ]; then
    warn "Web UI server not found: $srv"; return 1
  fi
  say "[+] Web UI: http://$WEB_BIND:$WEB_PORT/"
  python3 "$srv" --bind "$WEB_BIND" --port "$WEB_PORT" --lang "$LANG_UI" --probe-bin "$0"
}

# ---------------- main ----------------
main() {
  load_config
  parse_args "$@"

  case "$LANG_UI" in ru|en) :;; *) LANG_UI="ru";; esac
  case "$MODE" in full|safe|extream) :;; *) MODE="full";; esac
  case "$PROFILE" in auto|forensic|diagnostic|lite) :;; *) PROFILE="auto";; esac

  if [ "${INIT:-0}" -eq 1 ]; then
    init_wizard
    exit 0
  fi

  if [ "${WEB:-0}" -eq 1 ]; then
    webui_start
    exit $?
  fi

  if [ -n "${OUTDIR:-}" ] && [ "$OUTDIR" != "/var/tmp" ]; then
    warn "$(tr WARN_OUTDIR) (ignoring --outdir=$OUTDIR)"
  fi

  OUTBASE="$(pick_outdir)"
  check_free_space_warn || true
  clean_tmp_dir || true
  clean_old_outputs || true

  host="$(hostname 2>/dev/null || cat /proc/sys/kernel/hostname 2>/dev/null || echo keenetic)"
  host="$(sanitize_name "$host")"
  ts="$(ts_utc_path)"
  BASE="keenetic-maxprobe-${host}-$$-${ts}"
  WORK="$OUTBASE/${BASE}.work"
  ARCHIVE="$OUTBASE/${BASE}.tar.gz"

  ensure_dir "$WORK" || die "Cannot create workdir: $WORK"
  for d in meta analysis ndm entware net web sys fs tmp; do
    ensure_dir "$WORK/$d" || true
  done

  RUNLOG="$WORK/meta/run.log"
  ERRLOG="$WORK/meta/errors.log"
  : >"$RUNLOG" 2>/dev/null || true
  : >"$ERRLOG" 2>/dev/null || true

  PHASE_FILE="$WORK/meta/phase.txt"
  PROGRESS_FILE="$WORK/meta/progress.txt"
  printf '%s\n' "0/0" >"$PROGRESS_FILE" 2>/dev/null || true
  printf '%s\n' "starting..." >"$PHASE_FILE" 2>/dev/null || true

  START_EPOCH="$(date +%s 2>/dev/null || echo 0)"

  trap 'stop_spinner 2>/dev/null || true' INT TERM EXIT

  ensure_dir "$WORK/tmp" || true
  opkg_snapshot "$WORK/tmp/opkg_before.txt" || true

  TOTAL_STEPS=0
  TOTAL_STEPS=$((TOTAL_STEPS + 1))
  TOTAL_STEPS=$((TOTAL_STEPS + 1))
  TOTAL_STEPS=$((TOTAL_STEPS + 1))
  TOTAL_STEPS=$((TOTAL_STEPS + 1))
  TOTAL_STEPS=$((TOTAL_STEPS + 1))
  TOTAL_STEPS=$((TOTAL_STEPS + 1))
  TOTAL_STEPS=$((TOTAL_STEPS + 1))
  if [ "$MODE" = "full" ] || [ "$MODE" = "extream" ]; then TOTAL_STEPS=$((TOTAL_STEPS + 1)); fi
  TOTAL_STEPS=$((TOTAL_STEPS + 1))
  TOTAL_STEPS=$((TOTAL_STEPS + 1))
  TOTAL_STEPS=$((TOTAL_STEPS + 1))
  TOTAL_STEPS=$((TOTAL_STEPS + 1))
  TOTAL_STEPS=$((TOTAL_STEPS + 1))
  TOTAL_STEPS=$((TOTAL_STEPS + 1))
  TOTAL_STEPS=$((TOTAL_STEPS + 1))
  TOTAL_STEPS=$((TOTAL_STEPS + 1))
  TOTAL_STEPS=$((TOTAL_STEPS + 1))

  printf '%s/%s\n' "$STEP_NO" "$TOTAL_STEPS" >"$PROGRESS_FILE" 2>/dev/null || true

  start_spinner || true
  say "$(tr STARTING)"

  step "Meta: basic info" collect_meta
  step "System: /proc snapshots" collect_proc
  step "System: commands" collect_sys_commands
  step "Filesystem: mirror configs" mirror_filesystems
  step "Entware: inventory" collect_entware
  step "Network: snapshots" collect_network
  step "Network: HTTP/RCI probe" collect_http_probe
  if [ "$MODE" = "full" ] || [ "$MODE" = "extream" ]; then
    step "Web: extended probe" collect_web_probe
  fi
  step "Firewall: snapshot" collect_firewall
  step "KeeneticOS: ndmc snapshots" collect_ndmc
  step "Collectors: optional languages" run_collectors_parallel
  step "Analysis: sensitive map" scan_sensitive
  step "Analysis: redaction guides" write_redaction_guides
  step "Analysis: reports" generate_reports
  step "Cleanup: temp packages" cleanup_temp_packages
  step "Packing: archive" pack_archive

  stop_spinner || true

  if [ -f "$ARCHIVE" ]; then
    say "$(tr DONE) $ARCHIVE"
    [ -f "$ARCHIVE.sha256" ] && say "[+] SHA256: $ARCHIVE.sha256" || true
  else
    warn "Archive was not created (check meta/errors.log). Workdir kept: $WORK"
    exit 1
  fi

  step "Cleanup: workdir" cleanup_workdir
}

main "$@"
